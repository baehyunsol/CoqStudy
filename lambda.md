| 목차 |
|-------------------|
|!![[collapsible, default=hidden]]  |
|[[toc]]|

# Lambda Calculus

함수형 언어를 공부하다 보면 자주 만나는 람다대수에 관한 내용들을 정리해놓은 문서입니다. 람다대수는 컴퓨터 프로그램을 설명하는 방식 중 하나입니다. 튜링 기계와 튜링 완전성에 대해서는 들어보셨을 텐데, 람다대수는 튜링 기계로 표현가능한 모든 프로그램을 표현할 수 있습니다. 또한, 람다대수로 표현가능한 모든 프로그램은 튜링기계로 표현가능합니다. 아주 강력하죠?

## 정의

람다대수의 정의는 아주 간단합니다. 람다 대수는 함수를 정의하고, 적용하는 것만으로 모든 프로그램을 표현합니다. 그래서 쓰이는 기호들도 함수의 정의와 적용밖에 없어요.

예를 들어서, 숫자 `n` 하나를 받아서 `n + 1`을 반환하는 함수를 정의해보겠습니다.

> `λx.x+1`

`+`라는 기호는 원래 람다 대수에 없지만 설명의 편의를 위해서 썼습니다. `λ`는 새로운 함수를 정의하기 위해서 쓰입니다. `λ` 뒤에 함수에 쓰일 변수의 이름이 오고, `.` 뒤에는 함수의 내용이 옵니다. 변수의 이름은 아무렇게나 써도 상관없습니다. 예를 들어, `λx.x`와 `λy.y`는 동일한 함수입니다. 둘다 자기자신을 반환하는 항등함수입니다. 이처럼 변수의 이름이 달라도 형태가 동일하면 동일한 함수라는 걸 [[char=alpha]]-equivalence라고 합니다.

함수의 적용(application)도 간단합니다. 방금 만든 함수`λx.x+1`에 `1`이란 숫자를 넣고 싶으면 아래와 같이 쓰면 됩니다.

> `(λx.x+1) 1`

함수를 적고, 그 뒤에 적용하고 싶은 값을 적으면 됩니다. 가독성을 위해서 괄호를 적었습니다. 그렇다면 저 적용의 계산과정은 어떻게 될까요? 람다대수의 모든 계산은 대입/치환으로 이뤄져있습니다. `λx.N a`라는 식은 `N` 안에 등장하는 모든 `x`라는 문자를 `a`로 치환함으로써 계산됩니다. 즉, `(λx.x+1) 1` 은 `1+1`인 거죠.

### 다변수 함수

방금 본게 람다대수의 전부입니다. 아주 간단하죠? 위의 예시에서는 인수를 하나만 받는 함수만 다뤘습니다. 만약 인수 2개를 받아서 둘이 더하는 함수를 정의하고 싶다면 어떻게 할까요? Currying을 이용하면 됩니다.

> `λx.λy.x+y`

저게 어떻게 이변수 함수가 될 수 있을까요? `(λx.λy.x+y) 2 3`을 계산해보겠습니다. 람다대수에서 함수의 적용(application)은 왼쪽부터 되므로 `(λx.λy.x+y) 2 3`은 `((λx.λy.x+y) 2) 3`로 계산됩니다.

> `(λx.λy.x+y) 2 3` -> `(λy.2+y) 3` -> `2+3`

우리가 의도했던 이변수 덧셈함수가 나옵니다. 참 쉽죠?

## 예시

위에서 본 정의를 이용하여 다양한 함수들을 만들어보겠습니다. 위에서는 설명의 편의를 위해 여러 기호 (`+`, 자연수)들을 사용했지만, 이제부터는 아래의 기호들만 사용하겠습니다.

- `λ`, `.`, `(`, `)`
- 이름
  - 소문자로만 이뤄진 이름은 변수명으로, 대문자로만 이뤄진 이름은 정의로 사용하겠습니다.
- `:=`
  - 원래 람다대수에는 없는 기호지만, 설명의 편의를 위해 추가하겠습니다.
  - `TRUE`라는 값을 `λx.λy.x`라고 정의한다면, 매번 7글자를 치기 귀찮으니 `TRUE := λx.λy.x`라고 선언한 다음에 `TRUE`라는 이름을 이용하겠습니다.

### 논리식

람다대수를 이용해서 참/거짓을 정의해보겠습니다.

- `TRUE := λx.λy.x`
- `FALSE := λx.λy.y`

저게 어떻게 참/거짓인지 알쏭달쏭합니다. 논리 연산자를 정의하면서 저 식들이 어떻게 참/거짓이 되는지를 살펴보겠습니다. 먼저 `NOT` 연산자를 정의해보겠습니다.

- `NOT := λb.b FALSE TRUE`

저 정의를 봐도 알쏭달쏭하죠? `NOT TRUE`가 `FALSE`가 되는지 확인해봅시다. 람다대수의 모든 과정은 대입/치환이라고 했죠? 각 치환들을 단계별로 보여드리겠습니다.

1. `NOT TRUE`
  - `NOT`의 정의를 펼치겠습니다.
1. `(λb.b FALSE TRUE) TRUE`
  - `b`를 `TRUE`로 치환합니다.
1. `TRUE FALSE TRUE`
  - `TRUE`의 정의를 펼치겠습니다.
1. `λx.λy.x FALSE TRUE`
  - `x`는 `FALSE`로, `y`는 `TRUE`로 치환합니다.
1. `FALSE`

`NOT TRUE`가 `FALSE`가 됐습니다. 신기하죠? `NOT FALSE`도 동일합니다.

이번에는 `AND`, `OR`을 정의해보겠습니다.

- `AND := λx.λy.x y FALSE`
- `OR := λx.λy.x TRUE y`

벌써 재밌죠? `AND TRUE TRUE`를 계산해봅시다.

1. `AND TRUE TRUE`
  - `AND`의 정의를 펼치겠습니다.
1. `(λx.λy.x y FALSE) TRUE TRUE`
  - `x`를 `TRUE`로 치환합니다.
1. `(λy.TRUE y FALSE) TRUE`
  - `y`를 `TRUE`로 치환합니다.
1. `TRUE TRUE FALSE`
  - `TRUE`의 정의를 펼치겠습니다.
1. `(λx.λy.x) TRUE FALSE`
  - `x`를 `TRUE`로 치환합니다.
1. `TRUE`

왜 이렇게 되는 걸까요? 원리가 궁금하니 `OR FALSE`를 계산해봅시다.

1. `OR FALSE`
  - `OR`의 정의를 펼치겠습니다.
1. `(λx.λy.x TRUE y) FALSE`
  - `x`를 `FALSE`로 치환합니다.
1. `λy.FALSE TRUE y`
  - `FALSE`의 정의를 펼치겠습니다.
  - `FALSE`의 정의 안에 `y`라는 문자가 이미 포함돼 있는데, 밖에 있는 `y`와의 충돌을 피하기 위해서 이름을 `w`로 바꾸겠습니다.
    - 람다대수에서 변수의 이름은 마음껏 바꿀 수 있습니다. 이걸 [[char=alpha]]-conversion이라고 합니다.
1. `λy.((λx.λw.w) TRUE y)`
  - `x`를 `TRUE`로, `w`를 `y`로 치환합니다.
1. `λy.y`

`OR FALSE`를 하니 항등함수가 나왔습니다. `FALSE`와 다른 값을 `OR`할 경우 다른 값에 의해서 결과가 결정되니, 항등함수가 말이 됩니다. 똑같은 원리로 `OR TRUE`를 하면 상수함수 `TRUE`가 나오고 `AND FALSE`를 하면 상수함수 `FALSE`가 나옵니다.

### 자연수

이 문서의 시작에서 람다대수로 모든 것을 표현할 수 있다고 설명했습니다. 대입과 치환만으로 자연수 연산을 표현할 수 있다니 신기하죠? 지금부터 그 방법을 살펴보겠습니다. 먼저 자연수를 정의합시다.

- `ZERO := λf.λx.x`
- `ONE := λf.λx.f x`
- `TWO := λf.λx.f (f x)`

자연수의 정의만 봐서는 원리를 파악하기 어렵습니다. 이해를 돕기 위해 다른 연산들을 정의해보겠습니다. 먼저 `SUCC`함수를 정의하겠습니다. `SUCC`은 Coq의 `S`에 해당됩니다. Python으로 써보면 `lambda x: x + 1` 정도가 되겠네요.

- `SUCC := λn.λf.λx.f (n f x)`

저기에 `ZERO`를 집어 넣으면 `ONE`이 나올까요? 직접 한 번 해봅시다.

1. `SUCC ZERO`
  - `SUCC`의 정의를 펼치겠습니다.
1. `(λn.λf.λx.f (n f x)) ZERO`
  - `n`을 `ZERO`로 치환합니다.
1. `λf.λx.f (ZERO f x)`
  - `ZERO`의 정의를 펼치겠습니다.
  - `ZERO` 정의 안의 `f`를 `g`로, `x`를 `y`로 바꿔서 펼치겠습니다.
1. `λf.λx.f ((λg.λy.y) f x)`
  - `ZERO` 정의 안의 `g`를 `f`로 치환하겠습니다.
1. `λf.λx.f ((λy.y) x)`
  - `ZERO` 정의 안의 `y`를 `x`로 치환하겠습니다.
1. `λf.λx.f x`
  - `ONE`의 정의와 모양이 똑같아 졌습니다.

신기하군요. 덧셈 함수와 곱셈 함수도 정의만 해보겠습니다. 따로 확인해보진 않을 테니 궁금한 분들은 직접 계산해보시기 바랍니다.

- `PLUS := λm.λn.λf.λx.m f (n f x)`
- `MUL := λm.λn.λf.m (n f)`

---

[[center]]

[메인으로 돌아가기](index.html)

[[/center]]
