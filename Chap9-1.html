<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>Chap9-1</title>
    
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"/>
    <!--<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> -->
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/><link href="header.css" rel="stylesheet"/>
    
</head>

<body>


    <header>
<p><div class="topmenu deactivated"><a href="index.html">Home</a> <a href="index.html#index-by-chapter">단원별 목차</a> <a href="index.html#index-by-keyword">키워드 목차</a> <a href="Appendix.html">부록</a></div><div class="mobileview"><a id="navbutton">&#9776;</a></div></p>
    </header>



    <nav>
<p><a id="settingsopenbutton">&#9728;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p><div id="settingsmenu"> <a id="settingsclosebutton">&#10006;</a> <a id="changethemebutton">Set Light Theme</a> <a id="growhorizontalbutton">Grow Horizontally</a> <a id="shrinkhorizontalbutton">Shrink Horizontally</a> <a id="growfontbutton">Grow Font</a> <a id="shrinkfontbutton">Shrink Font</a> </div></p></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<table><thead id="table-collapse-toggle-0" class="collapsible collapsed" onclick="collapse_table('0')"><tr><th>목차</th></tr></thead><tbody id="collapsible-table-0" class="invisible"><tr><td><div class="toc"><ol type="1"><li><a href="#curry-howard-correspondence">Curry Howard Correspondence</a><ol type="1"><li><a href="#proof-object">Proof Object</a></li><li><a href="#dependent-types">Dependent Types</a><ol type="1"><li><a href="#forall과--"><code class="inline-code-span">forall</code>과 <code class="inline-code-span">-&gt;</code></a></li></ol></li></ol></li></ol></div></td></tr></tbody></table><h1 id="curry-howard-correspondence">Curry Howard Correspondence</h1><p>지금까지 Coq을 이용해서 증명을 하는 법들도 배웠고 프로그래밍을 하는 법도 배웠습니다. 이전의 단원들에서는 둘을 다른 것처럼 다뤘습니다. 과연 둘은 완전 분리된 개념일까요? 그렇지 않습니다. <code class="inline-code-span">Inductive</code>를 이용해서 <code class="inline-code-span">bool</code>과 <code class="inline-code-span">ev</code>를 둘 다 정의할 수 있던 건 우연이 아닙니다. 함수의 type을 <code class="inline-code-span">nat -&gt; nat</code>이라고 쓰고 <u>p이면 q이다</u>를 <code class="inline-code-span">p -&gt; q</code>라고 썼죠? 둘 다 <code class="inline-code-span">-&gt;</code>가 들어가는 것도 우연이 아닙니다.</p><p>Coq의 증명을 프로그래밍에 비유해보겠습니다. <a href="Chap7-2.html#refevidence">7장</a>에서 증거라는 개념을 배웠죠? 증명은 증거로 이뤄져있습니다. 예를 들어서 <code class="inline-code-span">A-&gt;B</code>의 증명은 <code class="inline-code-span">A</code>의 증거를 <code class="inline-code-span">B</code>의 증거로 바꾸는 과정이라고 생각할 수 있습니다. 여기서 우리는 아래와 같은 대응 관계를 얻을 수 있습니다.</p><table><thead><tr><th>Coq 증명</th><th>프로그래밍</th></tr></thead><tbody><tr><td>증거</td><td>값 (1, 2, 3...)</td></tr><tr><td><code class="inline-code-span">Prop</code>들</td><td>type (int, float...)</td></tr><tr><td>증명 (증거들의 tree)</td><td>자료구조</td></tr></tbody></table><p>위의 대응관계를 이용해서 Coq 코드를 다시 읽어보겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Inductive</span><span class="color-white"> ev </span><span class="color-white">:</span><span class="color-white"> nat </span><span class="color-white">-&gt;</span> <span class="color-gold">Prop</span> <span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">  <span class="color-white">|</span><span class="color-white"> ev_0 </span><span class="color-white">:</span><span class="color-white"> ev </span><span class="color-gold">0</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">  <span class="color-white">|</span><span class="color-white"> ev_SS (n </span><span class="color-white">:</span><span class="color-white"> nat) (</span><span class="color-gold">H</span> <span class="color-white">:</span><span class="color-white"> ev n) </span><span class="color-white">:</span><span class="color-white"> ev (</span><span class="color-gold">S</span><span class="color-white"> (</span><span class="color-gold">S</span><span class="color-white"> n))</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(0)">Copy</button></pre><p><code class="inline-code-span">:</code>를 뭐라고 읽어야할까요? <code class="inline-code-span">(n: nat)</code>의 <code class="inline-code-span">:</code>는 <u>has type</u>이라고 읽는게 적당합니다. 즉, <code class="inline-code-span">(n: nat)</code>은 <u><code class="inline-code-span">n</code> has type <code class="inline-code-span">nat</code></u>이라고 읽습니다. 아래에서는요? <code class="inline-code-span">ev_0 : ev 0</code>의 <code class="inline-code-span">:</code>는 <u>is a proof of</u>라고 읽습니다. 즉, <code class="inline-code-span">ev_0 : ev 0</code>는 <u><code class="inline-code-span">ev_0</code> is a proof of <code class="inline-code-span">ev 0</code></u>라고 읽습니다.</p><p>첫번째 해석은 익숙하겠지만, 두번째 해석은 좀 낯설 수 있습니다. 또한, 첫번째 해석과 두번째 해석이 결과적으로 같은 말이라는 사실을 받아들이기는 더 어려울 수 있습니다. 이번 단원에서는 저 두 해석이 왜 동일한지 쭉 살펴보겠습니다.</p><blockquote>방금 본 대응관계를 <em>Curry-Howard correspondence</em>라고 합니다. </blockquote><h2 id="proof-object">Proof Object</h2><p>방금 본 대응관계를 이용해서 <code class="inline-code-span">ev</code>를 더 자세하게 살펴보겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> ev_SS </span><span class="color-white">:</span><span class="color-white"> forall n </span><span class="color-white">:</span><span class="color-white"> nat</span><span class="color-white">,</span><span class="color-white"> ev n </span><span class="color-white">-&gt;</span><span class="color-white"> ev (</span><span class="color-gold">S</span><span class="color-white"> (</span><span class="color-gold">S</span><span class="color-white"> n))</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(1)">Copy</button></pre><p><code class="inline-code-span">ev_SS</code>의 type은 위와 같습니다. 저걸 대응관계에 넣어서 풀어보면 &quot;<code class="inline-code-span">ev_SS</code>는 자연수 <code class="inline-code-span">n</code> 하나와 증거 <code class="inline-code-span">ev n</code> 하나를 받는 함수이며, 반환하는 값은 <code class="inline-code-span">ev (S (S n))</code>이라는 명제의 증거이다.&quot;라고 읽힙니다.</p><p>같은 맥락에서, 아래의 세 증명은 완전히 동일합니다.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> ev_4 </span><span class="color-white">:</span><span class="color-white"> ev </span><span class="color-gold">4</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  apply ev_SS</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  apply ev_SS</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  apply ev_0</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> ev_4&apos; </span><span class="color-white">:</span><span class="color-white"> ev </span><span class="color-gold">4</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">  apply (ev_SS </span><span class="color-gold">2</span><span class="color-white">)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code"><span class="color-white">  apply (ev_SS </span><span class="color-gold">0</span><span class="color-white">)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code"><span class="color-white">  apply (ev_0)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> ev_4&apos;&apos; </span><span class="color-white">:</span><span class="color-white"> ev </span><span class="color-gold">4</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">17</span><span class="code-fence-code"><span class="color-white">  apply (ev_SS </span><span class="color-gold">2</span><span class="color-white"> (ev_SS </span><span class="color-gold">0</span><span class="color-white"> (ev_0)))</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">18</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">19</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">20</span><span class="code-fence-code"><span class="color-gold">Print</span><span class="color-white"> ev_4</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> ev_4   = ev_SS 2 (ev_SS 0 ev_0) : ev 4 </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">21</span><span class="code-fence-code"><span class="color-gold">Print</span><span class="color-white"> ev_4&apos;</span><span class="color-white">.</span><span class="color-white">  (*</span><span class="color-gray">{-</span><span class="color-gray"> ev_4&apos;  = ev_SS 2 (ev_SS 0 ev_0) : ev 4 </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">22</span><span class="code-fence-code"><span class="color-gold">Print</span><span class="color-white"> ev_4&apos;&apos;</span><span class="color-white">.</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> ev_4&apos;&apos; = ev_SS 2 (ev_SS 0 ev_0) : ev 4 </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(2)">Copy</button></pre><p><a href="Chap6-4.html">6-4 단원</a>에서 <code class="inline-code-span">apply</code>에 인수를 줄 수도 있고 안 줄 수도 있는 걸 봤죠? 그때는 <code class="inline-code-span">apply</code> 뒤에 함수가 왔고 이번엔 <code class="inline-code-span">ev</code>가 왔지만 <code class="inline-code-span">ev</code>와 함수는 본질적으로 동일합니다. <code class="inline-code-span">ev</code>도 인수를 받아서 증거를 반환하거든요. <code class="inline-code-span">ev</code>들이 반환하는 증거가 모여서 <code class="inline-code-span">ev 4</code>가 되면 증명이 끝납니다.</p><p>이것은 Coq가 내부적으로 동작하는 원리와도 연관돼 있습니다. <code class="inline-code-span">ev 4</code>를 증명하고 싶다고 하면 Coq는 <em><strong><code class="inline-code-span">ev 4</code>라는 type을 가진</strong></em> Proof Object를 만듭니다. (type이 저렇게 생겼습니다!) 그리고 그 proof object를 증명하기 위한 모든 증거를 다 제공하면 증명이 끝납니다. 각 과정에서 proof object의 모양을 보고 싶으면 <code class="inline-code-span">Show Proof</code>라는 명령어를 쓰면 됩니다.</p><p><a id="keywordshowproof"></a></p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> ev_4 </span><span class="color-white">:</span><span class="color-white"> ev </span><span class="color-gold">4</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">  <span class="color-gold">Show</span> <span class="color-gold">Proof</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> ?Goal </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  apply ev_SS</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">  <span class="color-gold">Show</span> <span class="color-gold">Proof</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> (ev_SS 2 ?Goal) </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  apply ev_SS</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code">  <span class="color-gold">Show</span> <span class="color-gold">Proof</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> (ev_SS 2 (ev_SS 0 ?Goal)) </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">  apply ev_0</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code">  <span class="color-gold">Show</span> <span class="color-gold">Proof</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> (ev_SS 2 (ev_SS 0 ev_0)) </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(3)">Copy</button></pre><p>위와 같이 증명이 진행되는 과정을 Coq가 보여줍니다.</p><h2 id="dependent-types">Dependent Types</h2><p>또다른 proof object를 살펴보겠습니다.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> ev_plus4 </span><span class="color-white">:</span><span class="color-white"> forall n</span><span class="color-white">,</span><span class="color-white"> ev n </span><span class="color-white">-&gt;</span><span class="color-white"> ev (</span><span class="color-gold">4</span> <span class="color-white">+</span><span class="color-white"> n)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">  <span class="color-gold">Show</span> <span class="color-gold">Proof</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> ?Goal </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  intros n </span><span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">  <span class="color-gold">Show</span> <span class="color-gold">Proof</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> (fun (n : nat) (H : ev n) =&gt; ?Goal) </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  simpl</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code">  <span class="color-gold">Show</span> <span class="color-gold">Proof</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> (fun (n : nat) (H : ev n) =&gt; ?Goal : ev (4 + n)) </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">  apply ev_SS</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code">  <span class="color-gold">Show</span> <span class="color-gold">Proof</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> (fun (n : nat) (H : ev n) =&gt; ev_SS (S (S n)) ?Goal : ev (4 + n)) </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">  apply ev_SS</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code">  <span class="color-gold">Show</span> <span class="color-gold">Proof</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> (fun (n : nat) (H : ev n) =&gt; ev_SS (S (S n)) (ev_SS n ?Goal) : ev (4 + n)) </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code"><span class="color-white">  apply </span><span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code">  <span class="color-gold">Show</span> <span class="color-gold">Proof</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> (fun (n : nat) (H : ev n) =&gt; ev_SS (S (S n)) (ev_SS n H) : ev (4 + n)) </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code"><span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(4)">Copy</button></pre><p>Proof object 자체의 내용은 크게 중요하지 않고, 복습을 위해서 적어보았습니다. 이번에 중요하게 살펴볼 것은 위 표현의 type들입니다. 우리가 증명하고자 하는 것의 type은 함수입니다. <code class="inline-code-span">forall n</code>과 증거 <code class="inline-code-span">ev n</code>을 받아서 또다른 증거 <code class="inline-code-span">ev (4 + n)</code>을 내놓습니다.</p><p>동일한 식을 다른 표현 방식으로 나타내보겠습니다. 아래를 봅시다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> ev_plus4&apos; </span><span class="color-white">:</span><span class="color-white"> forall n</span><span class="color-white">,</span><span class="color-white"> ev n </span><span class="color-white">-&gt;</span><span class="color-white"> ev (</span><span class="color-gold">4</span> <span class="color-white">+</span><span class="color-white"> n) </span><span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  fun (n </span><span class="color-white">:</span><span class="color-white"> nat) </span><span class="color-white">=&gt;</span><span class="color-white"> fun (</span><span class="color-gold">H</span> <span class="color-white">:</span><span class="color-white"> ev n) </span><span class="color-white">=&gt;</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">    ev_SS (</span><span class="color-gold">S</span><span class="color-white"> (</span><span class="color-gold">S</span><span class="color-white"> n)) (ev_SS n </span><span class="color-gold">H</span><span class="color-white">)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> ev_plus4&apos;&apos; (n </span><span class="color-white">:</span><span class="color-white"> nat) (</span><span class="color-gold">H</span> <span class="color-white">:</span><span class="color-white"> ev n)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">                    <span class="color-white">:</span><span class="color-white"> ev (</span><span class="color-gold">4</span> <span class="color-white">+</span><span class="color-white"> n) </span><span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  ev_SS (</span><span class="color-gold">S</span><span class="color-white"> (</span><span class="color-gold">S</span><span class="color-white"> n)) (ev_SS n </span><span class="color-gold">H</span><span class="color-white">)</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(5)">Copy</button></pre><p><code class="inline-code-span">ev_plus4</code>와 <code class="inline-code-span">ev_plus4&apos;</code>, <code class="inline-code-span">ev_plus4&apos;&apos;</code>는 전부 동일한 식을 다른 표현으로 나타낸 것입니다.</p><ul><li><code class="inline-code-span">ev_plus4&apos;</code>는 <code class="inline-code-span">Theroem</code>이 아닌 <code class="inline-code-span">Definition</code>을 이용해서 나타냈습니다. <code class="inline-code-span">ev_plus4</code>의 증명이 최종적으로 만드는 proof object를 <code class="inline-code-span">:=</code> 옆에 한번에 적어버렸네요.</li><li><code class="inline-code-span">ev_plu4&apos;&apos;</code>는 좀 더 함수스러운 형식으로 표현을 했습니다. <code class="inline-code-span">nat</code> 하나와 <code class="inline-code-span">ev n</code> 하나를 받아서 <code class="inline-code-span">ev (4 + n)</code>을 내놓는 type의 함수를 정의하고, 그 정의에는 proof object를 그대로 적었습니다.</li></ul><p><code class="inline-code-span">ev n</code>과 <code class="inline-code-span">ev (4 + n)</code>이 그 자체로 type인 점이 신기합니다. 왜냐하면 <code class="inline-code-span">n</code>은 함수의 첫번째 <u>인수</u>거든요. 이런 type들을 <em>dependent type</em>이라고 부릅니다. 보통의 프로그래밍 언어에선 거의 쓰이지 않지만 함수형 언어들은 요긴하게 써먹습니다.</p><h3 id="forall과--"><code class="inline-code-span">forall</code>과 <code class="inline-code-span">-&gt;</code></h3><p><a id="forallfunc"></a></p><p>방금 본 예제에서 (<code class="inline-code-span">ev_plus4&apos;</code>와 <code class="inline-code-span">ev_plus4&apos;&apos;</code>), <code class="inline-code-span">-&gt;</code>과 <code class="inline-code-span">forall</code>의 관계에 주목해봅시다. 얼핏 생각해보면 두 표현은 관련이 있어 보입니다. <u>모든 자연수에 대해, P이다</u>라는 표현과 <u>자연수이면 P이다</u>라는 표현은 같은 말 같거든요. 실제로도 그렇습니다. 아래에서 구체적인 예시를 보겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> ev_plus2 </span><span class="color-white">:</span> <span class="color-gold">Prop</span> <span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  forall n</span><span class="color-white">,</span><span class="color-white"> forall (</span><span class="color-gold">E</span> <span class="color-white">:</span><span class="color-white"> ev n)</span><span class="color-white">,</span><span class="color-white"> ev (n </span><span class="color-white">+</span> <span class="color-gold">2</span><span class="color-white">)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> ev_plus2&apos; </span><span class="color-white">:</span> <span class="color-gold">Prop</span> <span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  forall n</span><span class="color-white">,</span><span class="color-white"> forall (_ </span><span class="color-white">:</span><span class="color-white"> ev n)</span><span class="color-white">,</span><span class="color-white"> ev (n </span><span class="color-white">+</span> <span class="color-gold">2</span><span class="color-white">)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> ev_plus2&apos;&apos; </span><span class="color-white">:</span> <span class="color-gold">Prop</span> <span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">  forall n</span><span class="color-white">,</span><span class="color-white"> ev n </span><span class="color-white">-&gt;</span><span class="color-white"> ev (n </span><span class="color-white">+</span> <span class="color-gold">2</span><span class="color-white">)</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(6)">Copy</button></pre><p><code class="inline-code-span">ev_plus2</code>와 <code class="inline-code-span">ev_plus2&apos;</code>, <code class="inline-code-span">ev_plus2&apos;&apos;</code>는 동일한 정의입니다.</p><p><code class="inline-code-span">ev_plus2</code>는 <code class="inline-code-span">forall</code>만을 이용한 정의입니다. <code class="inline-code-span">ev n</code>을 만족하는 모든 <code class="inline-code-span">n</code>이 <code class="inline-code-span">ev (n + 2)</code>도 만족한다는 뜻이죠. 근데 <code class="inline-code-span">E</code>를 보면 정의만 됐을 뿐, 언급되지 않습니다. 언급되지 않을 객체에 이름을 붙이는 건 낭비 같죠? 그래서 <code class="inline-code-span">ev_plus2&apos;</code>에서는 <code class="inline-code-span">_</code>라는 빈 이름을 사용했습니다. 이렇게 써보니 <code class="inline-code-span">forall</code>과 <code class="inline-code-span">_</code>를 같이 사용하는 방식도 낭비 같습니다. 그래서 나온 표현이 가장 아래의 <code class="inline-code-span">-&gt;</code>를 사용한 표현입니다.</p><hr/><div class="align-center"><p><a href="index.html">메인으로 돌아가기</a></p></div><div class="align-left"><p>&lt;&lt; <a href="Chap8-2.html">Chap8-2. Partial Maps</a></p></div><div class="align-right"><p><a href="Chap9-2.html">Chap9-2. Logical Connectives as Inductive Types</a> &gt;&gt;</p></div><script>/*<![CDATA[*/
const fenced_code_block_contents = ["Inductive ev : nat -> Prop :=\n  | ev_0 : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n)).", "Check ev_SS : forall n : nat, ev n -> ev (S (S n)).", "Theorem ev_4 : ev 4.\nProof.\n  apply ev_SS.\n  apply ev_SS.\n  apply ev_0.\n  Qed.\n\nTheorem ev_4' : ev 4.\nProof.\n  apply (ev_SS 2).\n  apply (ev_SS 0).\n  apply (ev_0).\n  Qed.\n\nTheorem ev_4'' : ev 4.\nProof.\n  apply (ev_SS 2 (ev_SS 0 (ev_0))).\n  Qed.\n\nPrint ev_4.   (*{- ev_4   = ev_SS 2 (ev_SS 0 ev_0) : ev 4 -}*)\nPrint ev_4'.  (*{- ev_4'  = ev_SS 2 (ev_SS 0 ev_0) : ev 4 -}*)\nPrint ev_4''. (*{- ev_4'' = ev_SS 2 (ev_SS 0 ev_0) : ev 4 -}*)", "Theorem ev_4 : ev 4.\nProof.\n  Show Proof.   (*{- ?Goal -}*)\n  apply ev_SS.\n  Show Proof.   (*{- (ev_SS 2 ?Goal) -}*)\n  apply ev_SS.\n  Show Proof.   (*{- (ev_SS 2 (ev_SS 0 ?Goal)) -}*)\n  apply ev_0.\n  Show Proof.   (*{- (ev_SS 2 (ev_SS 0 ev_0)) -}*)\n  Qed.", "Theorem ev_plus4 : forall n, ev n -> ev (4 + n).\nProof.\n  Show Proof.   (*{- ?Goal -}*)\n  intros n H.\n  Show Proof.   (*{- (fun (n : nat) (H : ev n) => ?Goal) -}*)\n  simpl.\n  Show Proof.   (*{- (fun (n : nat) (H : ev n) => ?Goal : ev (4 + n)) -}*)\n  apply ev_SS.\n  Show Proof.   (*{- (fun (n : nat) (H : ev n) => ev_SS (S (S n)) ?Goal : ev (4 + n)) -}*)\n  apply ev_SS.\n  Show Proof.   (*{- (fun (n : nat) (H : ev n) => ev_SS (S (S n)) (ev_SS n ?Goal) : ev (4 + n)) -}*)\n  apply H.\n  Show Proof.   (*{- (fun (n : nat) (H : ev n) => ev_SS (S (S n)) (ev_SS n H) : ev (4 + n)) -}*)\nQed.", "Definition ev_plus4' : forall n, ev n -> ev (4 + n) :=\n  fun (n : nat) => fun (H : ev n) =>\n    ev_SS (S (S n)) (ev_SS n H).\nDefinition ev_plus4'' (n : nat) (H : ev n)\n                    : ev (4 + n) :=\n  ev_SS (S (S n)) (ev_SS n H).", "Definition ev_plus2 : Prop :=\n  forall n, forall (E : ev n), ev (n + 2).\n\nDefinition ev_plus2' : Prop :=\n  forall n, forall (_ : ev n), ev (n + 2).\n\nDefinition ev_plus2'' : Prop :=\n  forall n, ev n -> ev (n + 2)."];

function copy_code_to_clipboard(index) {
    navigator.clipboard.writeText(fenced_code_block_contents[index]);
}/*]]>*/</script>
        <a id="bottom"></a>
    </article>




    <footer class="markdown">
<p><br/></p><p><br/></p><hr/><div class="align-center"><p>2021 ~ 2023 &copy; Baehyunsol</p></div>
    </footer>


    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
    
    
    <script src="header.js"></script>
    
<script src="collapsible_tables.js"></script></body>

</html>