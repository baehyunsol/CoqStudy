<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>Chap4-2</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> 
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/><link href="header.css" rel="stylesheet"/><link href="footer.css" rel="stylesheet"/>
    
</head>

<body>


    <header>
<p><a href="index.html">Home</a></p>
    </header>



    <nav>
<p><a id="settingsopenbutton">&#9728;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p><div id="settingsmenu"> <a id="settingsclosebutton">&#10006;</a> <a id="changethemebutton">Set Light Theme</a> <a id="loosepaddingbutton">&#8592; &#8594;</a> <a id="tightpaddingbutton">&#8594; &#8592;</a> </div></p></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<table><thead id="table-collapse-toggle-0" class="collapsible collapsed" onclick="collapse_table('0')"><tr><th> Table of Contents </th></tr></thead><tbody id="collapsible-table-0" class="invisible"><tr><td><div class="toc"><ol type="1"><li><a href="#higher-order-fuctions">Higher Order Fuctions</a><ol type="1"><li><a href="#function-as-argument">Function as argument</a></li><li><a href="#filter">filter</a></li><li><a href="#map">map</a></li><li><a href="#fold">fold</a></li><li><a href="#functions-that-return-other-functions">Functions that return other functions</a></li><li><a href="#currying">Currying</a><ol type="1"><li><a href="#uncurry-curry-curry-uncurry">uncurry curry curry uncurry</a></li></ol></li></ol></li></ol></div></td></tr></tbody></table><h1 id="higher-order-fuctions">Higher Order Fuctions</h1><p>함수형 언어들의 가장 큰 특징 중 하나는 함수들이 일급시민<span class="footnote-ref" id="footnote-ref-0"><a href="#footnote-cite-0">[0]</a></span>이라는 겁니다. 즉, 함수를 다른 함수에게 인자로 주거나, 함수가 함수를 반환하는 등 함수를 다른 모든 type들과 동일하게 취급합니다. 이 개념은 function pointer와는 조금 다릅니다. Function pointer도 함수를 다른 함수의 인자로 넘길 수 있게 해주지만 C언어에서 함수와 정수가 동일하게 다뤄지나요? 잘 모르겠네요.</p><p>고차 함수<span class="footnote-ref" id="footnote-ref-1"><a href="#footnote-cite-1">[1]</a></span>는 아주 다양한 기술들을 구사할 수 있게 해줍니다. Python 혹은 Rust에서 map/reduce/filter를 사용해보셨을 겁니다. 또한 저 함수들을 쓰면서 람다함수를 정의한 적도 있으실 겁니다. Coq에서는 해당 함수들을 어떻게 정의하는지 살펴보겠습니다.</p><h2 id="function-as-argument">Function as argument</h2><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> doit3times {</span><span class="color-gold">X</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">} (f </span><span class="color-white">:</span> <span class="color-gold">X</span> <span class="color-white">-&gt;</span> <span class="color-gold">X</span><span class="color-white">) (n </span><span class="color-white">:</span> <span class="color-gold">X</span><span class="color-white">) </span><span class="color-white">:</span> <span class="color-gold">X</span> <span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  f (f (f n))</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(0)">Copy</button></pre><p>함수 <code class="inline-code-span">f</code>와 값 <code class="inline-code-span">n</code>을 받아서 <code class="inline-code-span">f(f(f(n)))</code>을 반환하는 함수입니다. Type은 아래와 같습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> doit3times</span><span class="color-white">.</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> (?X -&gt; ?X) -&gt; ?X -&gt; ?X where ?X : [ |- Type] </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> @doit3times</span><span class="color-white">.</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> forall X : Type, (X -&gt; X) -&gt; X -&gt; X </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(1)">Copy</button></pre><p>Haskell에서 고차함수의 type 표현과 거의 비슷합니다.</p><h2 id="filter">filter</h2><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Fixpoint</span><span class="color-white"> filter {</span><span class="color-gold">X</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">} (test </span><span class="color-white">:</span> <span class="color-gold">X</span> <span class="color-white">-&gt;</span><span class="color-white"> bool) (l </span><span class="color-white">:</span><span class="color-white"> list </span><span class="color-gold">X</span><span class="color-white">) </span><span class="color-white">:</span><span class="color-white"> list </span><span class="color-gold">X</span> <span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  match l with
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">  <span class="color-white">|</span><span class="color-white"> nil </span><span class="color-white">=&gt;</span><span class="color-white"> nil
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">  <span class="color-white">|</span><span class="color-white"> h </span><span class="color-white">::</span><span class="color-white"> t </span><span class="color-white">=&gt;</span> <span class="color-violet">if</span><span class="color-white"> test h
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">    <span class="color-violet">then</span><span class="color-white"> h </span><span class="color-white">::</span><span class="color-white"> (filter test t)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">    <span class="color-violet">else</span><span class="color-white"> filter test t
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">  end</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(2)">Copy</button></pre><p><code class="inline-code-span">filter</code> 구현입니다. 제대로 구현했는지 검사해보겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Fixpoint</span><span class="color-white"> is_len1 {</span><span class="color-gold">X</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">} (l </span><span class="color-white">:</span><span class="color-white"> list </span><span class="color-gold">X</span><span class="color-white">) </span><span class="color-white">:</span><span class="color-white"> bool </span><span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  (length l) </span><span class="color-white">=?</span> <span class="color-gold">1</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gold">Compute</span><span class="color-white"> filter is_len1 [</span><span class="color-gold">[]</span><span class="color-white">; [</span><span class="color-gold">1</span><span class="color-white">]; [</span><span class="color-gold">2</span><span class="color-white">; </span><span class="color-gold">3</span><span class="color-white">]; [</span><span class="color-gold">4</span><span class="color-white">]; [</span><span class="color-gold">5</span><span class="color-white">; </span><span class="color-gold">6</span><span class="color-white">; </span><span class="color-gold">7</span><span class="color-white">]]</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(3)">Copy</button></pre><p>결과가 <code class="inline-code-span">[[1]; [4]]</code>이 나옵니다. 제대로 구현이 됐군요. filter에만 단한번 쓰기 위해서 <code class="inline-code-span">is_len1</code>을 정의하는 건 불필요해보입니다. 다행히도 Coq는 익명함수를 지원합니다. 아래의 예시를 보겠습니다.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-gold">Compute</span><span class="color-white"> filter (fun l </span><span class="color-white">=&gt;</span><span class="color-white"> (length l) </span><span class="color-white">=?</span> <span class="color-gold">1</span><span class="color-white">) [</span><span class="color-gold">[]</span><span class="color-white">; [</span><span class="color-gold">1</span><span class="color-white">]; [</span><span class="color-gold">2</span><span class="color-white">; </span><span class="color-gold">3</span><span class="color-white">]; [</span><span class="color-gold">4</span><span class="color-white">]; [</span><span class="color-gold">5</span><span class="color-white">; </span><span class="color-gold">6</span><span class="color-white">; </span><span class="color-gold">7</span><span class="color-white">]]</span><span class="color-white">.</span></span></span>
</code></pre><p><a id="keywordfun"></a></p><p>번거롭게 함수를 정의할 필요없이 <code class="inline-code-span">fun</code> 키워드를 통해서 익명함수를 정의하는 걸 볼 수 있습니다.</p><h2 id="map">map</h2><p>함수형 언어의 꽃인 <code class="inline-code-span">map</code>입니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Fixpoint</span><span class="color-white"> map {</span><span class="color-gold">X</span> <span class="color-gold">Y</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">} (f </span><span class="color-white">:</span> <span class="color-gold">X</span> <span class="color-white">-&gt;</span> <span class="color-gold">Y</span><span class="color-white">) (l </span><span class="color-white">:</span><span class="color-white"> list </span><span class="color-gold">X</span><span class="color-white">) </span><span class="color-white">:</span><span class="color-white"> list </span><span class="color-gold">Y</span> <span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  match l with
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">  <span class="color-white">|</span> <span class="color-gold">[]</span> <span class="color-white">=&gt;</span> <span class="color-gold">[]</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">  <span class="color-white">|</span><span class="color-white"> h </span><span class="color-white">::</span><span class="color-white"> t </span><span class="color-white">=&gt;</span><span class="color-white"> (f h) </span><span class="color-white">::</span><span class="color-white"> (map f t)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  end</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(5)">Copy</button></pre><p>아래는 심심해서 구현해본 <code class="inline-code-span">flat_map</code>입니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Fixpoint</span><span class="color-white"> flat_map {</span><span class="color-gold">X</span> <span class="color-gold">Y</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">} (f </span><span class="color-white">:</span> <span class="color-gold">X</span> <span class="color-white">-&gt;</span><span class="color-white"> list </span><span class="color-gold">Y</span><span class="color-white">) (l </span><span class="color-white">:</span><span class="color-white"> list </span><span class="color-gold">X</span><span class="color-white">) </span><span class="color-white">:</span><span class="color-white"> list </span><span class="color-gold">Y</span> <span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  match l with
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">  <span class="color-white">|</span> <span class="color-gold">[]</span> <span class="color-white">=&gt;</span> <span class="color-gold">[]</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">  <span class="color-white">|</span><span class="color-white"> h </span><span class="color-white">::</span><span class="color-white"> t </span><span class="color-white">=&gt;</span><span class="color-white"> (f h) </span><span class="color-white">++</span><span class="color-white"> (flat_map f t)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  end</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(6)">Copy</button></pre><p>아래는 심심해서 증명해본 <code class="inline-code-span">map_rev</code>입니다. <code class="inline-code-span">map rev</code>와 <code class="inline-code-span">rev map</code>은 동일하다는 걸 증명했습니다. 증명에 쓰기 위해서 도움정리를 먼저 증명했습니다.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Lemma</span><span class="color-white"> map_single </span><span class="color-white">:</span><span class="color-white"> forall (</span><span class="color-gold">X</span> <span class="color-gold">Y</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">) (f </span><span class="color-white">:</span> <span class="color-gold">X</span> <span class="color-white">-&gt;</span> <span class="color-gold">Y</span><span class="color-white">) (l </span><span class="color-white">:</span><span class="color-white"> list </span><span class="color-gold">X</span><span class="color-white">) (e </span><span class="color-white">:</span> <span class="color-gold">X</span><span class="color-white">)</span><span class="color-white">,</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  map f (l </span><span class="color-white">++</span><span class="color-white"> [e]) </span><span class="color-white">=</span><span class="color-white"> (map f l) </span><span class="color-white">++</span><span class="color-white"> [f e]</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  intros </span><span class="color-gold">X</span> <span class="color-gold">Y</span><span class="color-white"> f l e</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  induction l as [ </span><span class="color-white">|</span><span class="color-white"> h&apos; t&apos; </span><span class="color-gold">IHl</span><span class="color-white">&apos;]</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> l = [] </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">    reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> l = h&apos; :: t&apos; </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">    simpl</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">    rewrite </span><span class="color-gold">IHl</span><span class="color-white">&apos;</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code"><span class="color-white">    reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> map_rev </span><span class="color-white">:</span><span class="color-white"> forall (</span><span class="color-gold">X</span> <span class="color-gold">Y</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">) (f </span><span class="color-white">:</span> <span class="color-gold">X</span> <span class="color-white">-&gt;</span> <span class="color-gold">Y</span><span class="color-white">) (l </span><span class="color-white">:</span><span class="color-white"> list </span><span class="color-gold">X</span><span class="color-white">)</span><span class="color-white">,</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code"><span class="color-white">  map f (rev l) </span><span class="color-white">=</span><span class="color-white"> rev (map f l)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">17</span><span class="code-fence-code"><span class="color-white">  intros </span><span class="color-gold">X</span> <span class="color-gold">Y</span><span class="color-white"> f l</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">18</span><span class="code-fence-code"><span class="color-white">  induction l as [ </span><span class="color-white">|</span><span class="color-white"> h&apos; t&apos; </span><span class="color-gold">IHht</span><span class="color-white">&apos;]</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">19</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> l = [] </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">20</span><span class="code-fence-code"><span class="color-white">    reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">21</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> l = h&apos; :: t&apos; </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">22</span><span class="code-fence-code"><span class="color-white">    simpl</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">23</span><span class="code-fence-code"><span class="color-white">    rewrite </span><span class="color-white">&lt;-</span> <span class="color-gold">IHht</span><span class="color-white">&apos;</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">24</span><span class="code-fence-code"><span class="color-white">    rewrite map_single</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">25</span><span class="code-fence-code"><span class="color-white">    reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">26</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(7)">Copy</button></pre><h2 id="fold">fold</h2><p>Haskell이나 Rust의 fold, 혹은 Python의 reduce입니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Fixpoint</span><span class="color-white"> fold {</span><span class="color-gold">X</span> <span class="color-gold">Y</span><span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">} (f </span><span class="color-white">:</span> <span class="color-gold">X</span> <span class="color-white">-&gt;</span> <span class="color-gold">Y</span> <span class="color-white">-&gt;</span> <span class="color-gold">Y</span><span class="color-white">) (l </span><span class="color-white">:</span><span class="color-white"> list </span><span class="color-gold">X</span><span class="color-white">) (b </span><span class="color-white">:</span> <span class="color-gold">Y</span><span class="color-white">) </span><span class="color-white">:</span> <span class="color-gold">Y</span> <span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  match l with
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">  <span class="color-white">|</span> <span class="color-gold">[]</span> <span class="color-white">=&gt;</span><span class="color-white"> b
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">  <span class="color-white">|</span><span class="color-white"> h </span><span class="color-white">::</span><span class="color-white"> t </span><span class="color-white">=&gt;</span><span class="color-white"> f h (fold f t b)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  end</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(8)">Copy</button></pre><p>마지막 인수로 <code class="inline-code-span">b</code>가 있는 것을 유의하시기 바랍니다. 빈 list를 넘길 경우 <code class="inline-code-span">b</code>를 기본값으로 사용합니다.</p><h2 id="functions-that-return-other-functions">Functions that return other functions</h2><p>함수형 언어답게 함수를 반환하는 함수를 만들 수도 있습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> adder (n </span><span class="color-white">:</span><span class="color-white"> nat) </span><span class="color-white">:</span><span class="color-white"> nat </span><span class="color-white">-&gt;</span><span class="color-white"> nat </span><span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  plus n</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> add3 </span><span class="color-white">:</span><span class="color-white"> nat </span><span class="color-white">-&gt;</span><span class="color-white"> nat </span><span class="color-white">:=</span><span class="color-white"> adder </span><span class="color-gold">3</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(9)">Copy</button></pre><p><code class="inline-code-span">adder</code> 함수는 <code class="inline-code-span">n</code>을 더하는 함수를 반환합니다. 즉, <code class="inline-code-span">adder 3</code>은 자연수 값이 아니고 3을 더하는 함수입니다. 위의 코드에서 정의된 <code class="inline-code-span">add3</code>을 이용해서 <code class="inline-code-span">add3 4</code>를 하면 7이 나옵니다.</p><p>함수형 언어에서는 이를 partial application이라고 부릅니다. <code class="inline-code-span">plus</code>는 인수를 2개 받는 함수인데 <code class="inline-code-span">adder</code> 안에서는 인수를 하나만 줬죠? 나머지 한 인수는 <code class="inline-code-span">adder</code>의 인수로 들어옵니다. 이런 식으로 인수를 따로 주기 때문에 partial application이라고 부릅니다.</p><h2 id="currying">Currying</h2><p>함수형 언어를 배우면 항상 만나게되는 Curry 선생님입니다. Curry는 간단하게 말하면 <code class="inline-code-span">f(x, y)</code>를 <code class="inline-code-span">f(x)(y)</code>로 바꿔주는 함수입니다. 무슨 말인지 알듯말듯 하죠? 아래의 예시를 보면서 더 설명드리겠습니다.</p><p>먼저, Curry 함수의 정의는 아래와 같습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> prod_curry {</span><span class="color-gold">X</span> <span class="color-gold">Y</span> <span class="color-gold">Z</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">}
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  (f </span><span class="color-white">:</span> <span class="color-gold">X</span><span class="color-white"> * </span><span class="color-gold">Y</span> <span class="color-white">-&gt;</span> <span class="color-gold">Z</span><span class="color-white">) (x </span><span class="color-white">:</span> <span class="color-gold">X</span><span class="color-white">) (y </span><span class="color-white">:</span> <span class="color-gold">Y</span><span class="color-white">) </span><span class="color-white">:</span> <span class="color-gold">Z</span> <span class="color-white">:=</span><span class="color-white"> f (x</span><span class="color-white">,</span><span class="color-white"> y)</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(10)">Copy</button></pre><p>참고로 <code class="inline-code-span">(x, y)</code>는 pair의 notation이고 <code class="inline-code-span">X * Y</code>는 prod type의 notation입니다. 정의는 <a href="Appendix.html#currying">부록</a>에 있습니다. 위의 정의만 보고는 감이 잘 안 오실텐데 아래에서 실제 함수와 함께 용례를 보겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> add (x </span><span class="color-white">:</span><span class="color-white"> nat * nat) </span><span class="color-white">:</span><span class="color-white"> nat </span><span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  match x with
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">  <span class="color-white">|</span><span class="color-white"> (x</span><span class="color-white">,</span><span class="color-white"> y) </span><span class="color-white">=&gt;</span><span class="color-white"> x </span><span class="color-white">+</span><span class="color-white"> y
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  end</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> curry_add </span><span class="color-white">:=</span><span class="color-white"> prod_curry add</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(11)">Copy</button></pre><p>먼저 두 숫자를 더하는 <code class="inline-code-span">add</code>라는 함수를 만들었습니다. 그리고 <code class="inline-code-span">add</code>를 curry하여 <code class="inline-code-span">curry_add</code>라는 함수도 만들었습니다. 두 함수의 모양이 어떻게 다른지 아래를 보겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> add</span><span class="color-white">.</span><span class="color-white">                (*</span><span class="color-gray">{-</span><span class="color-gray"> nat * nat -&gt; nat </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> curry_add</span><span class="color-white">.</span><span class="color-white">          (*</span><span class="color-gray">{-</span><span class="color-gray"> nat -&gt; nat -&gt; nat </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gold">Compute</span><span class="color-white"> add(</span><span class="color-gold">3</span><span class="color-white">,</span> <span class="color-gold">4</span><span class="color-white">)</span><span class="color-white">.</span><span class="color-white">        (*</span><span class="color-gray">{-</span><span class="color-gray"> 7 </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-gold">Compute</span><span class="color-white"> curry_add(</span><span class="color-gold">3</span><span class="color-white">)(</span><span class="color-gold">4</span><span class="color-white">)</span><span class="color-white">.</span><span class="color-white">  (*</span><span class="color-gray">{-</span><span class="color-gray"> 7 </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(12)">Copy</button></pre><p>위를 보시면 감이 오실 겁니다. <code class="inline-code-span">add</code>는 <code class="inline-code-span">add(3, 4)</code> 꼴의 모양으로 썼지만 <code class="inline-code-span">curry_add</code>는 <code class="inline-code-span">curry_add(3)(4)</code> 꼴로 씁니다. 그래서 둘의 type도 다릅니다. 이것만 보시면 이런 함수가 왜 필요한지 의문이 들 겁니다.</p><p>Curry는 함수형 프로그래밍에서 아주 중요한 개념 중 하나인데<span class="footnote-ref" id="footnote-ref-2"><a href="#footnote-cite-2">[2]</a></span>, 너무 자세히 다루는 건 이 문서의 취지에 어긋나므로 대표적인 예시 몇개만 보겠습니다. 아래는 curry를 이용해서 partial application을 구현한 예시입니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> add3 </span><span class="color-white">:=</span><span class="color-white"> prod_curry add </span><span class="color-gold">3</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> add3</span><span class="color-white">.</span><span class="color-white">     (*</span><span class="color-gray">{-</span><span class="color-gray"> nat -&gt; nat </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gold">Compute</span><span class="color-white"> add3 </span><span class="color-gold">4</span><span class="color-white">.</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> 7 </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(13)">Copy</button></pre><p><a href="#functions-that-return-other-functions">위</a>에서 구현했던 <code class="inline-code-span">add3</code>를 더 간단하게 구현했습니다.</p><p>Curry가 있으면 당연히 uncurry도 있겠죠? 구현해보겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> prod_uncurry {</span><span class="color-gold">X</span> <span class="color-gold">Y</span> <span class="color-gold">Z</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">}
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  (f </span><span class="color-white">:</span> <span class="color-gold">X</span> <span class="color-white">-&gt;</span> <span class="color-gold">Y</span> <span class="color-white">-&gt;</span> <span class="color-gold">Z</span><span class="color-white">) (x </span><span class="color-white">:</span> <span class="color-gold">X</span><span class="color-white"> * </span><span class="color-gold">Y</span><span class="color-white">) </span><span class="color-white">:</span> <span class="color-gold">Z</span> <span class="color-white">:=</span><span class="color-white"> f (fst x) (snd x)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> @prod_curry</span><span class="color-white">.</span><span class="color-white">    (*</span><span class="color-gray">{-</span><span class="color-gray"> forall X Y Z : Type, (X * Y -&gt; Z) -&gt; X -&gt; Y -&gt; Z </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> @prod_uncurry</span><span class="color-white">.</span><span class="color-white">  (*</span><span class="color-gray">{-</span><span class="color-gray"> forall X Y Z : Type, (X -&gt; Y -&gt; Z) -&gt; X * Y -&gt; Z </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(14)">Copy</button></pre><p>curry의 정의와 아주 비슷하게 생겼습니다. 이번에는 <code class="inline-code-span">f(x)(y)</code>를 <code class="inline-code-span">f(x, y)</code>로 바꿔줍니다. 즉, <code class="inline-code-span">prod_uncurry (prod_curry add)</code>는 <code class="inline-code-span">add</code>와 동일합니다. 저 둘이 동일하다는 걸 아래에서 일반화된 형태로 증명해보겠습니다.</p><h3 id="uncurry-curry-curry-uncurry">uncurry curry curry uncurry</h3><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> uncurry_curry </span><span class="color-white">:</span><span class="color-white"> forall (</span><span class="color-gold">X</span> <span class="color-gold">Y</span> <span class="color-gold">Z</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">                        (f </span><span class="color-white">:</span> <span class="color-gold">X</span> <span class="color-white">-&gt;</span> <span class="color-gold">Y</span> <span class="color-white">-&gt;</span> <span class="color-gold">Z</span><span class="color-white">)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">                        x y</span><span class="color-white">,</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">prod_curry (prod_uncurry f) x y </span><span class="color-white">=</span><span class="color-white"> f x y</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(15)">Copy</button></pre><p>먼저 curry uncurry가 identity라는 걸 증명했습니다. 증명이 간단해서 먼저 적었습니다.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> curry_uncurry </span><span class="color-white">:</span><span class="color-white"> forall (</span><span class="color-gold">X</span> <span class="color-gold">Y</span> <span class="color-gold">Z</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">                        (f </span><span class="color-white">:</span><span class="color-white"> (</span><span class="color-gold">X</span><span class="color-white"> * </span><span class="color-gold">Y</span><span class="color-white">) </span><span class="color-white">-&gt;</span> <span class="color-gold">Z</span><span class="color-white">) (p </span><span class="color-white">:</span> <span class="color-gold">X</span><span class="color-white"> * </span><span class="color-gold">Y</span><span class="color-white">)</span><span class="color-white">,</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  prod_uncurry (prod_curry f) p </span><span class="color-white">=</span><span class="color-white"> f p</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  intros </span><span class="color-gold">X</span> <span class="color-gold">Y</span> <span class="color-gold">Z</span><span class="color-white"> f p</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  induction p as [x y]</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> x : X, y : Y </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">    assert (</span><span class="color-gold">H</span><span class="color-white">:</span><span class="color-white"> (prod_curry f) (x) (y) </span><span class="color-white">=</span><span class="color-white"> f (x</span><span class="color-white">,</span><span class="color-white"> y))</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">      { reflexivity</span><span class="color-white">.</span><span class="color-white"> }
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">    rewrite </span><span class="color-white">&lt;-</span> <span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code"><span class="color-white">    assert (</span><span class="color-gold">H2</span><span class="color-white">:</span><span class="color-white"> forall f2 </span><span class="color-white">:</span> <span class="color-gold">X</span> <span class="color-white">-&gt;</span> <span class="color-gold">Y</span> <span class="color-white">-&gt;</span> <span class="color-gold">Z</span><span class="color-white">,</span><span class="color-white"> (prod_uncurry f2) (x</span><span class="color-white">,</span><span class="color-white"> y) </span><span class="color-white">=</span><span class="color-white"> f2 x y)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code"><span class="color-white">      { reflexivity</span><span class="color-white">.</span><span class="color-white"> }
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code"><span class="color-white">    rewrite </span><span class="color-gold">H2</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code"><span class="color-white">    reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(16)">Copy</button></pre><p>그 다음은 uncurry curry가 identity라는 걸 증명했습니다. 증명이 아까보다 긴데 더 짧은게 있을지 모르겠습니다. 6번 줄에서 <code class="inline-code-span">induction p</code>를 이용해서 <code class="inline-code-span">f p</code> 꼴의 형태들을 전부 <code class="inline-code-span">f (x, y)</code>의 꼴로 바꿨습니다.</p><hr/><div class="align-center"><p><a href="index.html">메인으로 돌아가기</a></p></div><div class="align-left"><p>&lt;&lt; <a href="Chap4-1.html">Chap4-1. Polymorphism</a></p></div><div class="align-right"><p><a href="Chap5-1.html">Chap 5-1. Apply tactics</a> &gt;&gt;</p></div><hr class="footnote-hr"/><div class="mdxt-footnote-cites"><p><div class="footnote-cite"><a id="footnote-cite-0"></a>0. <a href="#footnote-ref-0"> [0]</a> 보통 first-class citizen을 일급시민이라고 번역하더군요. 썩 마음에 들진 않습니다.</div><div class="footnote-cite"><a id="footnote-cite-1"></a>1. <a href="#footnote-ref-1"> [1]</a> 보통 higher-order function을 고차함수라고 번역하더군요. 그럭저럭 마음에 듭니다.</div><div class="footnote-cite"><a id="footnote-cite-2"></a>2. <a href="#footnote-ref-2"> [2]</a> 실제로 하스켈 언어에서 모든 다변수함수는 curry돼 있습니다.</div></p></div><script>/*<![CDATA[*/
const fenced_code_block_contents = ["Definition doit3times {X : Type} (f : X -> X) (n : X) : X :=\n  f (f (f n)).", "Check doit3times. (*{- (?X -> ?X) -> ?X -> ?X where ?X : [ |- Type] -}*)\n\nCheck @doit3times. (*{- forall X : Type, (X -> X) -> X -> X -}*)", "Fixpoint filter {X : Type} (test : X -> bool) (l : list X) : list X :=\n  match l with\n  | nil => nil\n  | h :: t => if test h\n    then h :: (filter test t)\n    else filter test t\n  end.", "Fixpoint is_len1 {X : Type} (l : list X) : bool :=\n  (length l) =? 1.\n\nCompute filter is_len1 [[]; [1]; [2; 3]; [4]; [5; 6; 7]].", "", "Fixpoint map {X Y : Type} (f : X -> Y) (l : list X) : list Y :=\n  match l with\n  | [] => []\n  | h :: t => (f h) :: (map f t)\n  end.", "Fixpoint flat_map {X Y : Type} (f : X -> list Y) (l : list X) : list Y :=\n  match l with\n  | [] => []\n  | h :: t => (f h) ++ (flat_map f t)\n  end.", "Lemma map_single : forall (X Y : Type) (f : X -> Y) (l : list X) (e : X),\n  map f (l ++ [e]) = (map f l) ++ [f e].\nProof.\n  intros X Y f l e.\n  induction l as [ | h' t' IHl'].\n  - (*{- l = [] -}*)\n    reflexivity.\n  - (*{- l = h' :: t' -}*)\n    simpl.\n    rewrite IHl'.\n    reflexivity.\n  Qed.\n\nTheorem map_rev : forall (X Y : Type) (f : X -> Y) (l : list X),\n  map f (rev l) = rev (map f l).\nProof.\n  intros X Y f l.\n  induction l as [ | h' t' IHht'].\n  - (*{- l = [] -}*)\n    reflexivity.\n  - (*{- l = h' :: t' -}*)\n    simpl.\n    rewrite <- IHht'.\n    rewrite map_single.\n    reflexivity.\n  Qed.", "Fixpoint fold {X Y: Type} (f : X -> Y -> Y) (l : list X) (b : Y) : Y :=\n  match l with\n  | [] => b\n  | h :: t => f h (fold f t b)\n  end.", "Definition adder (n : nat) : nat -> nat :=\n  plus n.\n\nDefinition add3 : nat -> nat := adder 3.", "Definition prod_curry {X Y Z : Type}\n  (f : X * Y -> Z) (x : X) (y : Y) : Z := f (x, y).", "Definition add (x : nat * nat) : nat :=\n  match x with\n  | (x, y) => x + y\n  end.\n\nDefinition curry_add := prod_curry add.", "Check add.                (*{- nat * nat -> nat -}*)\nCheck curry_add.          (*{- nat -> nat -> nat -}*)\n\nCompute add(3, 4).        (*{- 7 -}*)\nCompute curry_add(3)(4).  (*{- 7 -}*)", "Definition add3 := prod_curry add 3.\n\nCheck add3.     (*{- nat -> nat -}*)\nCompute add3 4. (*{- 7 -}*)", "Definition prod_uncurry {X Y Z : Type}\n  (f : X -> Y -> Z) (x : X * Y) : Z := f (fst x) (snd x).\n\nCheck @prod_curry.    (*{- forall X Y Z : Type, (X * Y -> Z) -> X -> Y -> Z -}*)\nCheck @prod_uncurry.  (*{- forall X Y Z : Type, (X -> Y -> Z) -> X * Y -> Z -}*)", "Theorem uncurry_curry : forall (X Y Z : Type)\n                        (f : X -> Y -> Z)\n                        x y,\nprod_curry (prod_uncurry f) x y = f x y.\nProof.\n  reflexivity.\nQed.", "Theorem curry_uncurry : forall (X Y Z : Type)\n                        (f : (X * Y) -> Z) (p : X * Y),\n  prod_uncurry (prod_curry f) p = f p.\nProof.\n  intros X Y Z f p.\n  induction p as [x y].\n  - (*{- x : X, y : Y -}*)\n    assert (H: (prod_curry f) (x) (y) = f (x, y)).\n      { reflexivity. }\n    rewrite <- H.\n    assert (H2: forall f2 : X -> Y -> Z, (prod_uncurry f2) (x, y) = f2 x y).\n      { reflexivity. }\n    rewrite H2.\n    reflexivity.\n  Qed."];

function copy_code_to_clipboard(index) {
    navigator.clipboard.writeText(fenced_code_block_contents[index]);
}/*]]>*/</script>
        <a id="bottom"></a>
    </article>




    <footer class="markdown">
<p><br/></p><p><br/></p><hr/><div class="align-center"><p>2021 ~ 2022 (c) Baehyunsol</p></div>
    </footer>


    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
<script src="collapsible_tables.js"></script></body>

</html>