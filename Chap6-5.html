<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>Chap6-5</title>
    
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"/>
    <!--<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> -->
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/><link href="header.css" rel="stylesheet"/>
    
</head>

<body>


    <header>
<p><div class="topmenu deactivated"><a href="index.html">Home</a> <a href="index.html#index-by-chapter">단원별 목차</a> <a href="index.html#index-by-keyword">키워드 목차</a> <a href="Appendix.html">부록</a></div><div class="mobileview"><a id="navbutton">&#9776;</a></div></p>
    </header>



    <nav>
<p><a id="settingsopenbutton">&#9728;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p><div id="settingsmenu"> <a id="settingsclosebutton">&#10006;</a> <a id="changethemebutton">Set Light Theme</a> <a id="growhorizontalbutton">Grow Horizontally</a> <a id="shrinkhorizontalbutton">Shrink Horizontally</a> <a id="growfontbutton">Grow Font</a> <a id="shrinkfontbutton">Shrink Font</a> </div></p></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<table><thead id="table-collapse-toggle-0" class="collapsible collapsed" onclick="collapse_table('0')"><tr><th>목차</th></tr></thead><tbody id="collapsible-table-0" class="invisible"><tr><td><div class="toc"><ol type="1"><li><a href="#axioms">Axioms</a><ol type="1"><li><a href="#excluded-middle">Excluded Middle</a></li></ol></li></ol></div></td></tr></tbody></table><h1 id="axioms">Axioms</h1><p><a id="keywordaxiom"></a></p><p>공리는 증명 없이 참이라고 받아들여지는 명제를 말합니다. 어떤 체계의 공리가 잘못되면 그 체계 전체의 기반이 무너지므로 공리를 다룰 때는 항상 매우 조심해야합니다. Coq에서는 공리를 어떻게 다룰까요? 아래의 예시를 보겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Example</span><span class="color-white"> function_equality </span><span class="color-white">:</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  (fun x </span><span class="color-white">=&gt;</span><span class="color-white"> plus x </span><span class="color-gold">1</span><span class="color-white">) </span><span class="color-white">=</span><span class="color-white"> (fun x </span><span class="color-white">=&gt;</span><span class="color-white"> plus </span><span class="color-gold">1</span><span class="color-white"> x)</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(0)">Copy</button></pre><p><code class="inline-code-span">x =&gt; x + 1</code>과 <code class="inline-code-span">x =&gt; 1 + x</code>는 동일한 함수입니다! 하지만 Coq의 논리 체계 안에선 저 둘이 동일한 함수란 걸 증명할 방법이 없습니다. 이런 경우엔 <code class="inline-code-span">Axiom</code>이란 명령어를 사용해서 새로운 공리를 만들면 됩니다.</p><p><a id="funcext"></a></p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Axiom</span><span class="color-white"> functional_extensionality </span><span class="color-white">:</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  forall {</span><span class="color-gold">X</span> <span class="color-gold">Y</span><span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">} {f g </span><span class="color-white">:</span> <span class="color-gold">X</span> <span class="color-white">-&gt;</span> <span class="color-gold">Y</span><span class="color-white">}</span><span class="color-white">,</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  (forall (x </span><span class="color-white">:</span> <span class="color-gold">X</span><span class="color-white">)</span><span class="color-white">,</span><span class="color-white"> f x </span><span class="color-white">=</span><span class="color-white"> g x) </span><span class="color-white">-&gt;</span><span class="color-white"> f </span><span class="color-white">=</span><span class="color-white"> g</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(1)">Copy</button></pre><p>모든 input에 대해서 동일한 output을 반환하는 두 함수는 동일합니다. 앞으론 그 사실을 증명없이 참이라 받아들이고 사용하겠습니다. 공리는 참인 명제이므로 다른 명제들과 동일한 방식으로 <code class="inline-code-span">rewrite</code>나 <code class="inline-code-span">apply</code>등을 이용해서 사용할 수 있습니다. 아까 증명하던 명제를 다시 증명해보겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Example</span><span class="color-white"> function_equality </span><span class="color-white">:</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  (fun x </span><span class="color-white">=&gt;</span><span class="color-white"> plus x </span><span class="color-gold">1</span><span class="color-white">) </span><span class="color-white">=</span><span class="color-white"> (fun x </span><span class="color-white">=&gt;</span><span class="color-white"> plus </span><span class="color-gold">1</span><span class="color-white"> x)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  apply functional_extensionality</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  intros x</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  apply add_comm</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(2)">Copy</button></pre><p>참 쉽죠?</p><h2 id="excluded-middle">Excluded Middle</h2><p>Coq에서는 아래의 명제도 증명불가능합니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> excluded_middle </span><span class="color-white">:</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  forall </span><span class="color-gold">P</span> <span class="color-white">:</span> <span class="color-gold">Prop</span><span class="color-white">,</span> <span class="color-gold">P</span> <span class="color-white">\/</span> <span class="color-white">~</span><span class="color-gold">P</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(3)">Copy</button></pre><p>모든 명제는 참 혹은 거짓이니까 당연히 저것도 성립하지 않겠냐 싶겠지만 Coq에선 저걸 증명할 수 없습니다. 책에선 <u>Coq가 classical logic이 아닌 constructive logic을 사용하기 때문에 의도적으로 빼놓았다</u>고 했는데 필요하시면 Axiom으로 추가해서 사용해도 됩니다.</p><hr/><div class="align-center"><p><a href="index.html">메인으로 돌아가기</a></p></div><div class="align-left"><p>&lt;&lt; <a href="Chap6-4.html">Chap6-4. Programming with Propositions</a></p></div><div class="align-right"><p><a href="Chap7-1.html">Chap7-1. Inductively defined Propositions</a> &gt;&gt;</p></div><script>/*<![CDATA[*/
const fenced_code_block_contents = ["Example function_equality :\n  (fun x => plus x 1) = (fun x => plus 1 x).", "Axiom functional_extensionality :\n  forall {X Y: Type} {f g : X -> Y},\n  (forall (x : X), f x = g x) -> f = g.", "Example function_equality :\n  (fun x => plus x 1) = (fun x => plus 1 x).\nProof.\n  apply functional_extensionality.\n  intros x.\n  apply add_comm.", "Theorem excluded_middle :\n  forall P : Prop, P \\/ ~P."];

function copy_code_to_clipboard(index) {
    navigator.clipboard.writeText(fenced_code_block_contents[index]);
}/*]]>*/</script>
        <a id="bottom"></a>
    </article>




    <footer class="markdown">
<p><br/></p><p><br/></p><hr/><div class="align-center"><p>2021 ~ 2023 &copy; Baehyunsol</p></div>
    </footer>


    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
    
    
    <script src="header.js"></script>
    
<script src="collapsible_tables.js"></script></body>

</html>