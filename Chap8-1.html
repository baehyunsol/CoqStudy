<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>Chap8-1</title>
    
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"/>
    <!--<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> -->
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/><link href="header.css" rel="stylesheet"/>
    
</head>

<body>


    <header>
<p><div class="topmenu deactivated"><a href="index.html">Home</a> <a href="index.html#index-by-chapter">단원별 목차</a> <a href="index.html#index-by-keyword">키워드 목차</a> <a href="Appendix.html">부록</a></div><div class="mobileview"><a id="navbutton">&#9776;</a></div></p>
    </header>



    <nav>
<p><a id="settingsopenbutton">&#9728;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p><div id="settingsmenu"> <a id="settingsclosebutton">&#10006;</a> <a id="changethemebutton">Set Light Theme</a> <a id="growhorizontalbutton">Grow Horizontally</a> <a id="shrinkhorizontalbutton">Shrink Horizontally</a> <a id="growfontbutton">Grow Font</a> <a id="shrinkfontbutton">Shrink Font</a> </div></p></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<table><thead id="table-collapse-toggle-0" class="collapsible collapsed" onclick="collapse_table('0')"><tr><th>목차</th></tr></thead><tbody id="collapsible-table-0" class="invisible"><tr><td><div class="toc"><ol type="1"><li><a href="#total-maps">Total Maps</a><ol type="1"><li><a href="#string">string</a></li><li><a href="#구현">구현</a></li></ol></li></ol></div></td></tr></tbody></table><h1 id="total-maps">Total Maps</h1><p><a href="Chap3-4.html">예전</a>에 map을 구현했습니다. 그때는 아직 Coq을 잘 모를 때라 아주 간단하게 구현하고 넘어갔는데, 이젠 좀 더 제대로 구현해보겠습니다.</p><p>이번 단원에선 total map과 partial map을 구현할 건데 그 중 total map을 먼저 구현하겠습니다. 둘의 차이는 map에 없는 원소를 찾으려고 할 때의 결과입니다. total map은 존재하지 않는 원소를 찾으려고 하면 처음에 지정된 기본값을 반환하지만, partial map은 <code class="inline-code-span">None</code>을 반환합니다.</p><p>Rust로 비유하자면 <code class="inline-code-span">TotalMap::get(k: K) -&gt; V</code>, <code class="inline-code-span">PartialMap::get(k: K) -&gt; Option&lt;V&gt;</code>입니다.</p><div class="box"><p><span class="size-giant"> imports </span></p><p>책에선 지금까지 Coq Standard Library를 사용하지 않고 설명을 했습니다. 만약 자연수 대소비교가 필요하다면 이전 단원에서 정의했던 함수를 사용하는 방식으로요. 그래서 저도 import와 관련된 언급을 하지 않고 진행했습니다. 하지만 이제부터는 std lib에서 import를 해서 진행을 한다네요. 여기서부터는 이 문서의 코드들을 실행시킬 때 아래의 library들을 import하고 진행하시면 됩니다!</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">From</span> <span class="color-gold">Coq</span> <span class="color-gold">Require</span> <span class="color-gold">Import</span> <span class="color-gold">Arith</span><span class="color-white">.</span><span class="color-gold">Arith</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gold">From</span> <span class="color-gold">Coq</span> <span class="color-gold">Require</span> <span class="color-gold">Import</span> <span class="color-gold">Bool</span><span class="color-white">.</span><span class="color-gold">Bool</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">Require</span> <span class="color-gold">Export</span> <span class="color-gold">Coq</span><span class="color-white">.</span><span class="color-gold">Strings</span><span class="color-white">.</span><span class="color-gold">String</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gold">From</span> <span class="color-gold">Coq</span> <span class="color-gold">Require</span> <span class="color-gold">Import</span> <span class="color-gold">Logic</span><span class="color-white">.</span><span class="color-gold">FunctionalExtensionality</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-gold">From</span> <span class="color-gold">Coq</span> <span class="color-gold">Require</span> <span class="color-gold">Import</span> <span class="color-gold">Lists</span><span class="color-white">.</span><span class="color-gold">List</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-gold">Import</span> <span class="color-gold">ListNotations</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(0)">Copy</button></pre></div><div class="box"><p><span class="size-giant"> Locate </span></p><p><a id="keywordlocate"></a></p><p>책에서 <code class="inline-code-span">Locate</code>라는 명령어를 소개하던데 저도 언급을 하고 넘어가겠습니다. 만약 Coq를 사용하다가 <code class="inline-code-span">+</code>라는 기호가 어디서 정의됐는지 궁금해지면 아래와 같은 명령어를 쓰면 됩니다.</p><blockquote><code class="inline-code-span">Locate &quot;+&quot;</code> </blockquote><p>그럼 <code class="inline-code-span">+</code>가 포함된 <code class="inline-code-span">Notation</code>들이 전부 나옵니다.</p></div><h2 id="string">string</h2><p>다시 total map의 구현으로 돌아오겠습니다. 먼저, <code class="inline-code-span">string</code>에 대해서 살펴보겠습니다. 이전에 map을 구현할 때는 자연수를 key로 사용했지만 이젠 <code class="inline-code-span">string</code>을 사용합니다. <code class="inline-code-span">string</code>이 어떻게 정의돼 있는지 궁금해서 공식문서의 일부분을 가져왔습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Inductive</span><span class="color-white"> string </span><span class="color-white">:</span> <span class="color-gold">Set</span> <span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">  <span class="color-white">|</span> <span class="color-gold">EmptyString</span> <span class="color-white">:</span><span class="color-white"> string
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">  <span class="color-white">|</span> <span class="color-gold">String</span> <span class="color-white">:</span><span class="color-white"> ascii </span><span class="color-white">-&gt;</span><span class="color-white"> string </span><span class="color-white">-&gt;</span><span class="color-white"> string</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(1)">Copy</button></pre><p><code class="inline-code-span">string</code>의 정의는 list와 아주 비슷하게 돼 있습니다. <code class="inline-code-span">list ascii</code>라고 생각하면 되겠군요. <code class="inline-code-span">ascii</code>의 정의도 살펴봤더니 <code class="inline-code-span">bool</code> 8개의 tuple로 돼 있습니다. 1byte를 그대로 표현했더군요.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> string_dec </span><span class="color-white">:</span><span class="color-white"> forall s1 s2 </span><span class="color-white">:</span><span class="color-white"> string</span><span class="color-white">,</span><span class="color-white"> {s1 </span><span class="color-white">=</span><span class="color-white"> s2} </span><span class="color-white">+</span><span class="color-white"> {s1 </span><span class="color-white">&lt;&gt;</span><span class="color-white"> s2}</span><span class="color-white">.</span></span></span>
</code></pre><p>위의 정의도 흥미로워서 갖고 왔습니다. <code class="inline-code-span">+</code>는 logical or 연산으로 정의된 거 같은데, 저 정의를 자세히 읽어보면 <code class="inline-code-span">s1과 s2는 같거나 다르다</code>입니다. 즉, 두 문자열이 같은지 다른지 항상 정할 수 있다는 뜻입니다. 영어 주석에도 <u>Equality is decidable</u>이라고 돼 있습니다.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Fixpoint</span><span class="color-white"> eqb s1 s2 </span><span class="color-white">:</span><span class="color-white"> bool </span><span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white"> match s1</span><span class="color-white">,</span><span class="color-white"> s2 with
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"> <span class="color-white">|</span> <span class="color-gold">EmptyString</span><span class="color-white">,</span> <span class="color-gold">EmptyString</span> <span class="color-white">=&gt;</span><span class="color-white"> true
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"> <span class="color-white">|</span> <span class="color-gold">String</span><span class="color-white"> c1 s1&apos;</span><span class="color-white">,</span> <span class="color-gold">String</span><span class="color-white"> c2 s2&apos; </span><span class="color-white">=&gt;</span> <span class="color-gold">Ascii</span><span class="color-white">.</span><span class="color-white">eqb c1 c2 &amp;&amp;&amp; eqb s1&apos; s2&apos;
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"> <span class="color-white">|</span><span class="color-white"> _</span><span class="color-white">,</span><span class="color-white">_ </span><span class="color-white">=&gt;</span><span class="color-white"> false
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white"> end</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-gold">Infix</span> <span class="color-white">&quot;</span><span class="color-green">=?</span><span class="color-white">&quot;</span> <span class="color-white">:=</span><span class="color-white"> eqb </span><span class="color-white">:</span><span class="color-white"> string_scope</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-gold">Notation</span> <span class="color-white">&quot;</span><span class="color-green">a &amp;&amp;&amp; b</span><span class="color-white">&quot;</span> <span class="color-white">:=</span><span class="color-white"> (</span><span class="color-violet">if</span><span class="color-white"> a </span><span class="color-violet">then</span><span class="color-white"> b </span><span class="color-violet">else</span><span class="color-white"> false)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code"><span class="color-white">  (at level </span><span class="color-gold">40</span><span class="color-white">,</span><span class="color-white"> left associativity) </span><span class="color-white">:</span><span class="color-white"> lazy_bool_scope</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(3)">Copy</button></pre><p>문자열 비교 함수 <code class="inline-code-span">eqb</code>의 정의입니다. 다른 type들이랑 이름이 겹치는 거 아닌가 싶을 수도 있지만 Module 안에 있기 때문에 괜찮습니다. <code class="inline-code-span">&amp;&amp;&amp;</code>은 처음 보는 기호라 뭔지 찾아봤더니 lazy andb로 정의돼 있더군요. 아래에 적어놨습니다. 일반 프로그래밍 언어에서 하는 것처럼 <code class="inline-code-span">a</code>가 거짓이면 <code class="inline-code-span">b</code>를 확인하지 않는 연산자입니다.</p><p>왜 굳이 lazy하게 썼는지는 모르겠네요. 최적화때문에 그런 걸까요?</p><p><a id="eqbrefl"></a></p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Lemma</span><span class="color-white"> eqb_refl x </span><span class="color-white">:</span><span class="color-white"> (x </span><span class="color-white">=?</span><span class="color-white"> x)</span><span class="color-white">%</span><span class="color-white">string </span><span class="color-white">=</span><span class="color-white"> true</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gold">Lemma</span><span class="color-white"> eqb_sym x y </span><span class="color-white">:</span><span class="color-white"> (x </span><span class="color-white">=?</span><span class="color-white"> y)</span><span class="color-white">%</span><span class="color-white">string </span><span class="color-white">=</span><span class="color-white"> (y </span><span class="color-white">=?</span><span class="color-white"> x)</span><span class="color-white">%</span><span class="color-white">string</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">Lemma</span><span class="color-white"> eqb_eq n m </span><span class="color-white">:</span><span class="color-white"> (n </span><span class="color-white">=?</span><span class="color-white"> m)</span><span class="color-white">%</span><span class="color-white">string </span><span class="color-white">=</span><span class="color-white"> true </span><span class="color-white">&lt;-&gt;</span><span class="color-white"> n </span><span class="color-white">=</span><span class="color-white"> m</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gold">Lemma</span><span class="color-white"> eqb_neq x y </span><span class="color-white">:</span><span class="color-white"> (x </span><span class="color-white">=?</span><span class="color-white"> y)</span><span class="color-white">%</span><span class="color-white">string </span><span class="color-white">=</span><span class="color-white"> false </span><span class="color-white">&lt;-&gt;</span><span class="color-white"> x </span><span class="color-white">&lt;&gt;</span><span class="color-white"> y</span><span class="color-white">.</span> </span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(4)">Copy</button></pre><p>그 다음은 비교와 관련된 정리 몇가지가 있습니다. 아주 자명한 사실들입니다. 자기자신과의 비교, 교환법칙 등이 설명돼있습니다.</p><div class="box"><p><a id="keywordampersand"></a></p><p>TODO</p><p><code class="inline-code-span">%</code> 기호가 뭔지 모르겠네요. <code class="inline-code-span">=?</code>가 generic이어서 type을 지정해주는 용도인 거 같기는 한데 정확히는 모르겠습니다.</p><p><code class="inline-code-span">x =? x0</code>라고 쓰니까 Coq가 <code class="inline-code-span">x</code>가 <code class="inline-code-span">nat</code>인 줄 알고 <code class="inline-code-span">(x =? x0)%string</code>이라고 하니까 Coq가 <code class="inline-code-span">x</code>가 <code class="inline-code-span">string</code>인 줄 아는 걸로 봐서 맞는 거 같습니다.</p></div><h2 id="구현">구현</h2><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> total_map (</span><span class="color-gold">A</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">) </span><span class="color-white">:=</span><span class="color-white"> string </span><span class="color-white">-&gt;</span> <span class="color-gold">A</span><span class="color-white">.</span></span></span>
</code></pre><p><code class="inline-code-span">total_map</code>의 정의는 위와 같습니다. 이전에는 type으로 정의했지만 이번에는 함수로 정의했습니다. 키를 받아서 값을 내놓는 동작을 함수처럼 보겠다는 것이죠. 이러면 <code class="inline-code-span">total_map</code>에서 값을 찾는 함수를 따로 만들 필요가 없다는 장점이 있습니다... 이미 만들었거든요!</p><p><a href="Chap4-2.html">4-2 단원</a>에서 봤듯이 함수도 일급객체이므로 <code class="inline-code-span">total_map</code>과 관련된 다양한 함수들을 만들 수 있습니다. 아래에서 몇가지 예시를 보겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> t_empty {</span><span class="color-gold">A</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">} (v </span><span class="color-white">:</span> <span class="color-gold">A</span><span class="color-white">) </span><span class="color-white">:</span><span class="color-white"> total_map </span><span class="color-gold">A</span> <span class="color-white">:=</span><span class="color-white"> (fun _ </span><span class="color-white">=&gt;</span><span class="color-white"> v)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> t_update {</span><span class="color-gold">A</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">} (m </span><span class="color-white">:</span><span class="color-white"> total_map </span><span class="color-gold">A</span><span class="color-white">)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">                    (x </span><span class="color-white">:</span><span class="color-white"> string) (v </span><span class="color-white">:</span> <span class="color-gold">A</span><span class="color-white">) </span><span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  fun x&apos; </span><span class="color-white">=&gt;</span> <span class="color-violet">if</span> <span class="color-gold">String</span><span class="color-white">.</span><span class="color-white">eqb x x&apos; </span><span class="color-violet">then</span><span class="color-white"> v </span><span class="color-violet">else</span><span class="color-white"> m x&apos;</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(6)">Copy</button></pre><p><code class="inline-code-span">t_empty</code>는 빈 <code class="inline-code-span">total_map</code>을 만드는 함수입니다. 항상 <code class="inline-code-span">v</code>를 반환하는 함수를 반환했습니다. 여기서 <code class="inline-code-span">v</code>는 기본값입니다. 빈 <code class="inline-code-span">total_map</code>은 항상 기본값을 반환하겠죠.</p><p><code class="inline-code-span">t_update</code>의 구현은 흥미롭습니다. 어떤 <code class="inline-code-span">total_map</code>을 받아서 거기에 (키, 값) 쌍을 추가하는 함수인데, 함수를 받아서 함수를 반환하도록 돼 있는 구현이 참신하네요.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Notation</span> <span class="color-white">&quot;</span><span class="color-green">&apos;_&apos; &apos;!-&gt;&apos; v</span><span class="color-white">&quot;</span> <span class="color-white">:=</span><span class="color-white"> (t_empty v)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  (at level </span><span class="color-gold">100</span><span class="color-white">,</span><span class="color-white"> right associativity)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gold">Notation</span> <span class="color-white">&quot;</span><span class="color-green">x &apos;!-&gt;&apos; v &apos;;&apos; m</span><span class="color-white">&quot;</span> <span class="color-white">:=</span><span class="color-white"> (t_update m x v)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  (at level </span><span class="color-gold">100</span><span class="color-white">,</span><span class="color-white"> v at next level</span><span class="color-white">,</span><span class="color-white"> right associativity)</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(7)">Copy</button></pre><p>몇가지 Notation을 정의했습니다. <code class="inline-code-span">_ -&gt; v</code>는 <code class="inline-code-span">v</code>를 기본값으로 하는 빈 <code class="inline-code-span">total_map</code>을 만들고, <code class="inline-code-span">x !-&gt; v; m</code>은 <code class="inline-code-span">m</code>에 (<code class="inline-code-span">x</code>, <code class="inline-code-span">v</code>)를 추가합니다. 저렇게만 보면 어떻게 쓰는지 모를 것 같아서 용례를 몇가지 갖고 왔습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Example</span><span class="color-white"> example_empty </span><span class="color-white">:=</span><span class="color-white"> (_ </span><span class="color-white">!-&gt;</span><span class="color-white"> false)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> examplemap </span><span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  ( </span><span class="color-white">&quot;</span><span class="color-green">bar</span><span class="color-white">&quot;</span> <span class="color-white">!-&gt;</span><span class="color-white"> true;
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">    <span class="color-white">&quot;</span><span class="color-green">foo</span><span class="color-white">&quot;</span> <span class="color-white">!-&gt;</span><span class="color-white"> true;
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">    _ </span><span class="color-white">!-&gt;</span><span class="color-white"> false
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">  )</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(8)">Copy</button></pre><p>아래의 예시를 보면 감이 잘 옵니다. 가장 아랫줄에 기본값을 <code class="inline-code-span">false</code>로 하는 빈 <code class="inline-code-span">total_map</code>을 만들고, 거기에 (<code class="inline-code-span">&quot;foo&quot;</code>, <code class="inline-code-span">true</code>)와 (<code class="inline-code-span">&quot;bar&quot;</code>, <code class="inline-code-span">true</code>)를 추가했습니다. 즉, <code class="inline-code-span">examplemap</code>은 <code class="inline-code-span">&quot;foo&quot;</code>와 <code class="inline-code-span">&quot;bar&quot;</code>에 대해서만 <code class="inline-code-span">true</code>를 반환하고 나머지는 전부 <code class="inline-code-span">false</code>를 반환합니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Lemma</span><span class="color-white"> t_update_eq </span><span class="color-white">:</span><span class="color-white"> forall (</span><span class="color-gold">A</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">) (m </span><span class="color-white">:</span><span class="color-white"> total_map </span><span class="color-gold">A</span><span class="color-white">) x v</span><span class="color-white">,</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  (x </span><span class="color-white">!-&gt;</span><span class="color-white"> v ; m) x </span><span class="color-white">=</span><span class="color-white"> v</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  intros </span><span class="color-gold">A</span><span class="color-white"> m x v</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  unfold t_update</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  rewrite eqb_refl</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">  reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(9)">Copy</button></pre><p>그냥 지나가면 섭섭하니까 증명을 하나 하고 지나가겠습니다. 어떤 <code class="inline-code-span">total_map</code>에 (<code class="inline-code-span">x</code>, <code class="inline-code-span">v</code>)를 추가하고 <code class="inline-code-span">x</code>를 요청하면 <code class="inline-code-span">v</code>를 반환합니다. 아주 당연한 얘기죠? <code class="inline-code-span">unfold t_update</code>를 하면 <code class="inline-code-span">if (x =? x) then v else m x</code>만 남습니다. <code class="inline-code-span">x =? x = true</code>임이 <a href="#eqbrefl">아까</a> 봤던 <code class="inline-code-span">eqb_refl</code>에 증명돼 있으므로 그걸 사용하면 증명이 끝납니다.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> t_update_same </span><span class="color-white">:</span><span class="color-white"> forall (</span><span class="color-gold">A</span> <span class="color-white">:</span> <span class="color-gold">Type</span><span class="color-white">) (m </span><span class="color-white">:</span><span class="color-white"> total_map </span><span class="color-gold">A</span><span class="color-white">) x</span><span class="color-white">,</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  (x </span><span class="color-white">!-&gt;</span><span class="color-white"> m x ; m) </span><span class="color-white">=</span><span class="color-white"> m</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  intros </span><span class="color-gold">A</span><span class="color-white"> m x</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  unfold t_update</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  apply functional_extensionality</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">  intros x0</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">  destruct (x </span><span class="color-white">=?</span><span class="color-white"> x0)</span><span class="color-white">%</span><span class="color-white">string eqn</span><span class="color-white">:</span> <span class="color-gold">E</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">  rewrite eqb_eq </span><span class="color-violet">in</span> <span class="color-gold">E</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> x = x0 </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code"><span class="color-white">    rewrite </span><span class="color-gold">E</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code"><span class="color-white">    reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> x != x0 </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code"><span class="color-white">    reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(10)">Copy</button></pre><p>아직도 섭섭해서 증명 하나를 더 했습니다. <a href="Chap6-5.html#funcext">옛날</a>에 봤던 <code class="inline-code-span">functional_extensionality</code>를 갖고 왔습니다.</p><hr/><div class="align-center"><p><a href="index.html">메인으로 돌아가기</a></p></div><div class="align-left"><p>&lt;&lt; <a href="Chap7-3.html">Chap7-3. Regular Expressions</a></p></div><div class="align-right"><p><a href="Chap8-2.html">Chap8-2. Partial Maps</a> &gt;&gt;</p></div><script>/*<![CDATA[*/
const fenced_code_block_contents = ["From Coq Require Import Arith.Arith.\nFrom Coq Require Import Bool.Bool.\nRequire Export Coq.Strings.String.\nFrom Coq Require Import Logic.FunctionalExtensionality.\nFrom Coq Require Import Lists.List.\nImport ListNotations.", "Inductive string : Set :=\n  | EmptyString : string\n  | String : ascii -> string -> string.", "", "Fixpoint eqb s1 s2 : bool :=\n match s1, s2 with\n | EmptyString, EmptyString => true\n | String c1 s1', String c2 s2' => Ascii.eqb c1 c2 &&& eqb s1' s2'\n | _,_ => false\n end.\n\nInfix \"=?\" := eqb : string_scope.\n\nNotation \"a &&& b\" := (if a then b else false)\n  (at level 40, left associativity) : lazy_bool_scope.", "Lemma eqb_refl x : (x =? x)%string = true.\nLemma eqb_sym x y : (x =? y)%string = (y =? x)%string.\nLemma eqb_eq n m : (n =? m)%string = true <-> n = m.\nLemma eqb_neq x y : (x =? y)%string = false <-> x <> y. ", "", "Definition t_empty {A : Type} (v : A) : total_map A := (fun _ => v).\n\nDefinition t_update {A : Type} (m : total_map A)\n                    (x : string) (v : A) :=\n  fun x' => if String.eqb x x' then v else m x'.", "Notation \"'_' '!->' v\" := (t_empty v)\n  (at level 100, right associativity).\n\nNotation \"x '!->' v ';' m\" := (t_update m x v)\n  (at level 100, v at next level, right associativity).", "Example example_empty := (_ !-> false).\n\nDefinition examplemap :=\n  ( \"bar\" !-> true;\n    \"foo\" !-> true;\n    _ !-> false\n  ).", "Lemma t_update_eq : forall (A : Type) (m : total_map A) x v,\n  (x !-> v ; m) x = v.\nProof.\n  intros A m x v.\n  unfold t_update.\n  rewrite eqb_refl.\n  reflexivity.\n  Qed.", "Theorem t_update_same : forall (A : Type) (m : total_map A) x,\n  (x !-> m x ; m) = m.\nProof.\n  intros A m x.\n  unfold t_update.\n  apply functional_extensionality.\n  intros x0.\n  destruct (x =? x0)%string eqn: E.\n  rewrite eqb_eq in E.\n  - (*{- x = x0 -}*)\n    rewrite E.\n    reflexivity.\n  - (*{- x != x0 -}*)\n    reflexivity.\n  Qed."];

function copy_code_to_clipboard(index) {
    navigator.clipboard.writeText(fenced_code_block_contents[index]);
}/*]]>*/</script>
        <a id="bottom"></a>
    </article>




    <footer class="markdown">
<p><br/></p><p><br/></p><hr/><div class="align-center"><p>2021 ~ 2023 &copy; Baehyunsol</p></div>
    </footer>


    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
    
    
    <script src="header.js"></script>
    
<script src="collapsible_tables.js"></script></body>

</html>