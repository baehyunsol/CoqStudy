<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>Chap1-3</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> 
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/><link href="header.css" rel="stylesheet"/><link href="footer.css" rel="stylesheet"/>
    
</head>

<body>


    <header>
<p><a href="index.html">Home</a></p>
    </header>



    <nav>
<p><a id="settingsopenbutton">&#9728;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p><div id="settingsmenu"> <a id="settingsclosebutton">&#10006;</a> <a id="changethemebutton">Set Light Theme</a> <a id="loosepaddingbutton">&#8592; &#8594;</a> <a id="tightpaddingbutton">&#8594; &#8592;</a> </div></p></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<table><thead id="table-collapse-toggle-0" class="collapsible collapsed" onclick="collapse_table('0')"><tr><th> Table of Contents </th></tr></thead><tbody id="collapsible-table-0" class="invisible"><tr><td><div class="toc"><ol type="1"><li><a href="#proofs">Proofs</a><ol type="1"><li><a href="#by-simplification">By Simplification</a></li><li><a href="#by-rewriting">By Rewriting</a></li><li><a href="#by-case-analysis">By Case Analysis</a></li><li><a href="#키워드-정리">키워드 정리</a></li></ol></li></ol></div></td></tr></tbody></table><h1 id="proofs">Proofs</h1><p>Coq는 <em>theorem prover</em>입니다. 즉, 증명이 핵심입니다. 아쉽게도 Coq가 증명을 대신 해주지는 않습니다. 사람이 theorem을 입력하고 그걸 증명하는데 사용할 전략들을 알려주면 Coq가 증명을 <em>보조</em>해줍니다. 이번 챕터에서는 증명의 전략들을 알아보겠습니다.</p><h2 id="by-simplification">By Simplification</h2><p><a id="ex1"></a></p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> plus_O_n </span><span class="color-white">:</span><span class="color-white"> forall n </span><span class="color-white">:</span><span class="color-white"> nat</span><span class="color-white">,</span><span class="color-white"> </span><span class="color-gold">0</span><span class="color-white"> </span><span class="color-white">+</span><span class="color-white"> n </span><span class="color-white">=</span><span class="color-white"> n</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  intros n</span><span class="color-white">.</span><span class="color-white"> simpl</span><span class="color-white">.</span><span class="color-white"> reflexivity</span><span class="color-white">.</span><span class="color-white"> </span><span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(0)">Copy</button></pre><p>위의 코드는 Coq를 이용한 간단한 증명과정을 나타냅니다.</p><ol type="1"><li>먼저, <code class="inline-code-span">Theorem</code> 키워드를 이용해서 정리를 정의합니다.<ul><li>여기서는 <code class="inline-code-span">plus_O_n</code>이라는 정리를 정의했습니다.</li><li>정리의 내용은 &apos;<em>모든 자연수 n에 대해서 0 + n = n이다</em>&apos;입니다.</li></ul></li><li>바로 다음에 <code class="inline-code-span">Proof</code> 키워드를 이용해서 <code class="inline-code-span">plus_O_n</code>을 증명합니다.</li><li><code class="inline-code-span">Proof</code> 키워드 다음에 증명에 쓰일 tactic이 쭉 나오고, <code class="inline-code-span">Qed</code> 키워드를 이용해서 증명이 끝났음을 선언합니다.</li></ol><p>각 tactic이 무슨 역할을 하는지는 아래의 <a href="#키워드-정리">키워드 정리</a>에서 자세하게 설명하겠습니다.</p><h2 id="by-rewriting">By Rewriting</h2><p><code class="inline-code-span">n = m</code>이면 context에 있는 모든 <code class="inline-code-span">m</code>을 <code class="inline-code-span">n</code>으로 rewrite해라? 라는 거 같은데? 물론 반대 방향으로 rewrite할 수도 있고.</p><h2 id="by-case-analysis">By Case Analysis</h2><h2 id="키워드-정리">키워드 정리</h2><div class="box"><p><a id="keywordtheorem"></a> <a id="keywordexample"></a></p><p><span class="size-giant">Theorem, Example</span></p><p>참이라고 주장하고 싶은 정리를 선언하는데 쓰입니다. <code class="inline-code-span">Theorem</code>과 <code class="inline-code-span">Example</code>은 semantic한 차이가 거의 없다고 문서에 나와있습니다. 문맥에 따라서 사람이 읽기 쉬운 키워드를 고르면 될 듯 합니다. 책에서는 <code class="inline-code-span">Theorem</code>이 수학적 증명에 가깝고, <code class="inline-code-span">Example</code>은 unit test에 가까운 용례로 쓰이는 듯 합니다.</p><p><code class="inline-code-span">Theorem</code>이나 <code class="inline-code-span">Example</code>의 뒤에는 바로 <code class="inline-code-span">Proof</code>가 와서 증명을 제공해야합니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Example</span><span class="color-white"> test_even1</span><span class="color-white">:</span><span class="color-white"> is_even </span><span class="color-gold">2</span><span class="color-white"> </span><span class="color-white">=</span><span class="color-white"> true</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> plus_O_n </span><span class="color-white">:</span><span class="color-white"> forall n </span><span class="color-white">:</span><span class="color-white"> nat</span><span class="color-white">,</span><span class="color-white"> </span><span class="color-gold">0</span><span class="color-white"> </span><span class="color-white">+</span><span class="color-white"> n </span><span class="color-white">=</span><span class="color-white"> n</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(1)">Copy</button></pre><p>위의 예시들은 책에서 쓰인 용례들을 그대로 갖고 온 것입니다. 책에서 <code class="inline-code-span">Theorem</code>과 <code class="inline-code-span">Example</code>을 어떤 뉘앙스로 사용하는지 확인하실 수 있습니다. 또한 저 용례에서 <code class="inline-code-span">Example</code>과 <code class="inline-code-span">Theorem</code>을 뒤바꿔서 실행해도 문제없이 돌아갑니다.</p><p><code class="inline-code-span">Lemma</code>, <code class="inline-code-span">Fact</code>, <code class="inline-code-span">Remark</code> 등의 키워드들도 위 키워드들과 거의 비슷한 역할을 합니다.</p><ul><li><a href="https://stackoverflow.com/questions/60101214/what-is-the-difference-between-definitions-and-theorems">stackoverflow</a></li><li><a href="#ex1">예시1</a></li><li><a href="Chap1-2.html#ex1">예시2</a></li></ul></div><div class="box"><p><a id="keywordintros"></a></p><p><span class="size-giant">intros</span></p><p><em>introduce</em>의 줄임말입니다. <code class="inline-code-span">Theorem</code>에서 <code class="inline-code-span">forall</code>로 선언돼 있는 부분들을... 잘 모르겠습니다.</p><p>Coq 인터프리터에 <code class="inline-code-span">forall n : nat, 1 + n = S n</code>을 넣고 <code class="inline-code-span">intros n</code>을 거치면 <code class="inline-code-span">n</code> 앞의 <code class="inline-code-span">forall</code>이 없어집니다... 정확히 뭐하는 건지 잘 모르겠습니다.</p><ul><li><a href="https://stackoverflow.com/questions/70482977/understanding-the-intros-keyword-work-in-coq">stackoverflow</a></li><li><a href="https://coq.inria.fr/refman/proof-engine/tactics.html#coq:tacv.intros">공식 문서 참고</a></li><li><a href="#ex1">예시1</a></li></ul></div><div class="box"><p><a id="keywordreflexivity"></a></p><p><span class="size-giant">reflexivity</span></p><p>등식의 양변이 동일한 값을 갖고 있는지 확인합니다.</p><ul><li><a href="#ex1">예시1</a></li></ul></div><div class="box"><p><a id="keywordsimpl"></a></p><p><span class="size-giant">simpl</span></p><p>등식의 양변을 간단한 형태로 정리합니다.</p><p>Coq 인터프리터에 <code class="inline-code-span">forall n : nat, 1 + n = S n</code>을 넣고 <code class="inline-code-span">simpl</code> tactic을 통과시키면 goal에 있던 <code class="inline-code-span">1 + n = S n</code>이 <code class="inline-code-span">S n = S n</code>으로 바뀌는 것을 확인할 수 있습니다. 덧셈함수의 <a href="Chap1-2.html#functionnatplus">정의</a>에 따르면 <code class="inline-code-span">(plus 1 n)</code>은 <code class="inline-code-span">(S (plus 0 n))</code>이고 그 값은 다시 <code class="inline-code-span">(S n)</code>이 되죠? Coq도 이 과정을 동일하게 거쳐서 <code class="inline-code-span">1 + n</code>을 <code class="inline-code-span">S n</code>으로 고칩니다.</p><p>함수의 정의에 값을 그대로 넣어서 간단한 형태로 정리한다는게 중요합니다. 만약 <code class="inline-code-span">1 + n = S n</code>이 아니라 <code class="inline-code-span">n + 1 = S n</code>을 넣고 <code class="inline-code-span">simpl</code>을 통과시키면 Coq는 아무것도 하지 못합니다. 정의를 이용해서는 첫번째 인수만 줄일 수 있거든요.</p><ul><li><a href="#ex1">예시1</a></li></ul></div><hr/><div class="align-center"><p><a href="index.html">메인으로 돌아가기</a></p></div><div class="align-left"><p>&lt;&lt; <a href="Chap1-2.html">Chap1-2. Natrual Numbers</a></p></div><div class="align-right"><p>다음 글이 없습니다.</p></div><script>/*<![CDATA[*/
const fenced_code_block_contents = ["Theorem plus_O_n : forall n : nat, 0 + n = n.\nProof.\n  intros n. simpl. reflexivity. Qed.", "Example test_even1: is_even 2 = true.\nTheorem plus_O_n : forall n : nat, 0 + n = n."];

function copy_code_to_clipboard(index) {
    navigator.clipboard.writeText(fenced_code_block_contents[index]);
}/*]]>*/</script>
        <a id="bottom"></a>
    </article>




    <footer class="markdown">
<p><br/></p><p><br/></p><hr/><div class="align-center"><p>2021 ~ 2022 (c) Baehyunsol</p><p>Powered by <a href="https://github.com/baehyunsol/MDxt">MDxt</a></p></div>
    </footer>


    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
<script src="collapsible_tables.js"></script></body>

</html>