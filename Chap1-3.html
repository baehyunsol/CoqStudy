<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>Chap1-3</title>
    
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"/>
    <!--<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> -->
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/><link href="header.css" rel="stylesheet"/>
    
</head>

<body>


    <header>
<p><div class="topmenu deactivated"><a href="index.html">Home</a> <a href="index.html#index-by-chapter">단원별 목차</a> <a href="index.html#index-by-keyword">키워드 목차</a> <a href="Appendix.html">부록</a></div><div class="mobileview"><a id="navbutton">&#9776;</a></div></p>
    </header>



    <nav>
<p><a id="settingsopenbutton">&#9728;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p><div id="settingsmenu"> <a id="settingsclosebutton">&#10006;</a> <a id="changethemebutton">Set Light Theme</a> <a id="growhorizontalbutton">Grow Horizontally</a> <a id="shrinkhorizontalbutton">Shrink Horizontally</a> <a id="growfontbutton">Grow Font</a> <a id="shrinkfontbutton">Shrink Font</a> </div></p></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<table><thead id="table-collapse-toggle-0" class="collapsible collapsed" onclick="collapse_table('0')"><tr><th>목차</th></tr></thead><tbody id="collapsible-table-0" class="invisible"><tr><td><div class="toc"><ol type="1"><li><a href="#proofs">Proofs</a><ol type="1"><li><a href="#by-simplification">By Simplification</a></li><li><a href="#by-rewriting">By Rewriting</a></li><li><a href="#by-case-analysis">By Case Analysis</a></li><li><a href="#키워드-정리">키워드 정리</a></li></ol></li></ol></div></td></tr></tbody></table><h1 id="proofs">Proofs</h1><p>Coq는 <em>theorem prover</em>입니다. 즉, 증명이 핵심입니다. 아쉽게도 Coq가 증명을 대신 해주지는 않습니다. 사람이 theorem을 입력하고 그걸 증명하는데 사용할 전략들을 알려주면 Coq가 증명을 <em>보조</em>해줍니다. 이번 챕터에서는 증명의 전략들을 알아보겠습니다.</p><h2 id="by-simplification">By Simplification</h2><p><a id="ex1"></a></p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> plus_O_n </span><span class="color-white">:</span><span class="color-white"> forall n </span><span class="color-white">:</span><span class="color-white"> nat</span><span class="color-white">,</span> <span class="color-gold">0</span> <span class="color-white">+</span><span class="color-white"> n </span><span class="color-white">=</span><span class="color-white"> n</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  intros n</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  simpl</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(0)">Copy</button></pre><p>위의 코드는 Coq를 이용한 간단한 증명과정을 나타냅니다.</p><ol type="1"><li>먼저, <code class="inline-code-span">Theorem</code> 키워드를 이용해서 정리를 정의합니다.<ul><li>여기서는 <code class="inline-code-span">plus_O_n</code>이라는 정리를 정의했습니다.</li><li>정리의 내용은 &apos;<em>모든 자연수 n에 대해서 0 + n = n이다</em>&apos;입니다.</li></ul></li><li>바로 다음에 <code class="inline-code-span">Proof</code> 키워드를 이용해서 <code class="inline-code-span">plus_O_n</code>을 증명합니다.</li><li><code class="inline-code-span">Proof</code> 키워드 다음에 증명에 쓰일 tactic이 쭉 나오고, <code class="inline-code-span">Qed</code> 키워드를 이용해서 증명이 끝났음을 선언합니다.</li></ol><p>각 tactic이 무슨 역할을 하는지는 아래의 <a href="#키워드-정리">키워드 정리</a>에서 자세하게 설명하겠습니다.</p><h2 id="by-rewriting">By Rewriting</h2><p><a id="ex2"></a></p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> plus_id_example </span><span class="color-white">:</span><span class="color-white"> forall n m</span><span class="color-white">:</span><span class="color-white">nat</span><span class="color-white">,</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  n </span><span class="color-white">=</span><span class="color-white"> m </span><span class="color-white">-&gt;</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  n </span><span class="color-white">+</span><span class="color-white"> n </span><span class="color-white">=</span><span class="color-white"> m </span><span class="color-white">+</span><span class="color-white"> m</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  intros n m</span><span class="color-white">.</span><span class="color-white">    (*</span><span class="color-gray">{-</span><span class="color-gray"> n m : nat </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">  intros </span><span class="color-gold">H</span><span class="color-white">.</span><span class="color-white">      (*</span><span class="color-gray">{-</span><span class="color-gray"> H: n = m </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">  rewrite </span><span class="color-white">-&gt;</span> <span class="color-gold">H</span><span class="color-white">.</span><span class="color-white">  (*</span><span class="color-gray">{-</span><span class="color-gray"> `n + n = m + m`이 `m + m = m + m`이 됩니다. </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">  reflexivity</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> 양변이 같음을 확인합니다. </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(1)">Copy</button></pre><p>이번에는 theorem의 형태가 조금 바뀌었죠? <code class="inline-code-span">-&gt;</code> 기호가 들어갔습니다. <code class="inline-code-span">-&gt;</code> 기호는 <code class="inline-code-span">p이면 q이다</code>의 의미를 나타내기 위해 쓰이며, <em>implies</em>라고 읽습니다.</p><p><code class="inline-code-span">intros</code>도 2번 등장합니다. 첫번째 <code class="inline-code-span">intros n m</code>은 Theorem 속에 <code class="inline-code-span">forall n m</code>으로 돼 있는 부분을 context에 집어넣고, 두번째 <code class="inline-code-span">intros H</code>는 <code class="inline-code-span">p이면 q이다</code>의 <code class="inline-code-span">p</code>를 context에 집어넣습니다. 즉, context 안에는 <code class="inline-code-span">H</code>라는 hypothesis가 있으며, <code class="inline-code-span">H</code>의 내용은 <code class="inline-code-span">H: n = m</code>입니다.</p><h2 id="by-case-analysis">By Case Analysis</h2><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> plus_1_neq_0 </span><span class="color-white">:</span><span class="color-white"> forall n </span><span class="color-white">:</span><span class="color-white"> nat</span><span class="color-white">,</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  (n </span><span class="color-white">+</span> <span class="color-gold">1</span><span class="color-white">) </span><span class="color-white">=?</span> <span class="color-gold">0</span> <span class="color-white">=</span><span class="color-white"> false</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(2)">Copy</button></pre><p>위와 같은 theorem을 생각해보겠습니다. 저걸 증명하려면 어떻게 해야할까요? 여기서는 <code class="inline-code-span">simpl</code> tactic이 통하지 않습니다. 덧셈 함수의 정의상 왼쪽 피연산자가 상수여야지만 pattern matching이 가능한데 그렇지 않거든요. <code class="inline-code-span">eqb</code> 함수 입장에서도 왼쪽의 <code class="inline-code-span">n + 1</code>을 pattern matching에 넣을 방법이 없습니다.</p><p>이때 사용하는 것이 <code class="inline-code-span">destruct</code> tactic입니다. 아래 예시를 봅시다.</p><p><a id="ex3"></a></p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  intros n</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  destruct n as [ </span><span class="color-white">|</span><span class="color-white"> n&apos;] eqn</span><span class="color-white">:</span><span class="color-gold">E</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> n = 0 </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">    reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> n = S n&apos; </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">    reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(3)">Copy</button></pre><p>이제 <code class="inline-code-span">n</code>을 <code class="inline-code-span">O</code>와 <code class="inline-code-span">S n&apos;</code>의 두 가지 경우로 나눠서 생각합니다. <code class="inline-code-span">[ | n&apos;]</code>은 <code class="inline-code-span">n</code>을 어떻게 나눌지를 정합니다. <code class="inline-code-span">n</code>의 type은 <code class="inline-code-span">nat</code>이고, <code class="inline-code-span">nat</code>의 constructor는 2개가 있으므로 우리는 대괄호 안에 두 개의 원소를 줘야합니다. 각 원소는 <code class="inline-code-span">|</code>로 구분합니다. <code class="inline-code-span">O</code>는 인수가 필요없는 constructor이므로, 첫번째 원소는 null이고 (그래서 <code class="inline-code-span">|</code> 앞에 아무것도 쓰지 않았습니다.) 두번째 원소는 <code class="inline-code-span">n&apos;</code>을 줬습니다. 이렇게 해서 subgoal이 2개가 생겼습니다.</p><p>그러면 Coq은 <code class="inline-code-span">n</code>을 <code class="inline-code-span">O</code>와 <code class="inline-code-span">S n&apos;</code>의 두가지 경우로 나눠서 생각하고, 저희는 각 경우에 대해서 증명을 하면 됩니다. 뒤의 <code class="inline-code-span">eqn: E</code>로 인해 context에 <code class="inline-code-span">E</code>가 추가됐습니다. 각 경우별로 <code class="inline-code-span">E: n = 0</code>과 <code class="inline-code-span">E: n = S n&apos;</code>으로 생성이 됩니다. 또한 저희가 증명해야할 문제는 <code class="inline-code-span">(0 + 1 =? 0) = false</code>과 <code class="inline-code-span">(S n&apos; + 1 =? 0) = false</code>이 됩니다.</p><p>그 다음의 <code class="inline-code-span">-</code>는 각 subgoal을 풀 tactic을 보여줍니다. 여기서는 각각 <code class="inline-code-span">reflexivity</code>만으로 증명이 되니까 상관이 없지만, 각 subgoal을 증명하는 과정이 길어질 경우 하나의 증명을 마치고 <code class="inline-code-span">-</code>를 쓰고 다음 증명을 시작하면 됩니다. 이렇게 2개의 subgoal을 풀고 나면 전체가 증명이 끝납니다. <code class="inline-code-span">-</code>은 쓰지 않아도 됩니다. 다만, 가독성을 위해서 쓰는 것을 권장합니다.</p><p><code class="inline-code-span">eqn: E</code>은 생략할 수 있습니다. 그 경우, context에 <code class="inline-code-span">E: n = 0</code>과 <code class="inline-code-span">E: n = S n&apos;</code>이 포함되지 않습니다.</p><h2 id="키워드-정리">키워드 정리</h2><div class="box"><p><a id="keyworddestruct"></a></p><p><span class="size-giant">destruct</span></p><p>예시에 자세히 설명이 돼 있으니 아래 링크를 참고해주세요.</p><p>위에서 쓰지 않았던 또다른 예시를 보여드리겠습니다.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> negb_involutive </span><span class="color-white">:</span><span class="color-white"> forall b </span><span class="color-white">:</span><span class="color-white"> bool</span><span class="color-white">,</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  negb (negb b) </span><span class="color-white">=</span><span class="color-white"> b</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  intros b</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  destruct b eqn</span><span class="color-white">:</span> <span class="color-gold">E</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> b = true </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">    reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> b = false </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">    reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(4)">Copy</button></pre><p><code class="inline-code-span">bool</code> type은 variant가 2개밖에 없습니다. 또한, 각 variant의 constructor는 인수가 0개라서 <code class="inline-code-span">as</code>와 대괄호를 쓸 필요가 없습니다. 위와 같은 방식으로 증명을 하면, Coq은 theorem에다가 <code class="inline-code-span">true</code>와 <code class="inline-code-span">false</code>를 각각 집어넣어서 식이 성립하는지 확인합니다.</p><p>또다른 예시를 보여드리겠습니다.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> andb_commutative </span><span class="color-white">:</span><span class="color-white"> forall b c</span><span class="color-white">,</span><span class="color-white"> andb b c </span><span class="color-white">=</span><span class="color-white"> andb c b</span><span class="color-white">.</span></span></span>
</code></pre><p>위와 같은 theorem을 증명하려면 어떻게 해야할까요? <code class="inline-code-span">b</code>와 <code class="inline-code-span">c</code>로 가능한 모든 경우의 수가 4가지밖에 없으니 브루트포스로 검증하는게 합리적입니다.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  intros b c</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  destruct b eqn</span><span class="color-white">:</span> <span class="color-gold">Eb</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> b = true </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">    destruct c eqn</span><span class="color-white">:</span> <span class="color-gold">Ec</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">    <span class="color-white">+</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> c = true </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">      reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code">    <span class="color-white">+</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> c = false </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">      reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> b = false </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code"><span class="color-white">    destruct c eqn</span><span class="color-white">:</span> <span class="color-gold">Ec</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code">    <span class="color-white">+</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> c = true </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code"><span class="color-white">      reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code">    <span class="color-white">+</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> c = false </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code"><span class="color-white">      reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code"><span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(6)">Copy</button></pre><p>그래서 위와 같이 3번째 줄에서 <code class="inline-code-span">b</code>를 <code class="inline-code-span">true</code>와 <code class="inline-code-span">false</code>로 나눈 뒤, 각각의 경우에 대해 <code class="inline-code-span">c</code>를 destruct하여 (5, 11번 줄) 모든 경우의 수를 따졌습니다. <code class="inline-code-span">b</code>, <code class="inline-code-span">c</code>의 값이 각각 확정되면 <code class="inline-code-span">reflexivity</code> tactic만을 이용해서 손쉽게 증명할 수 있습니다. <code class="inline-code-span">andb</code>의 정의에 직접 대입하면 결과가 나오거든요.</p><ul><li><a href="#ex3">예시1</a></li></ul></div><div class="box"><p><a id="keywordtheorem"></a> <a id="keywordexample"></a></p><p><span class="size-giant">Theorem, Example</span></p><p>참이라고 주장하고 싶은 정리를 선언하는데 쓰입니다. <code class="inline-code-span">Theorem</code>과 <code class="inline-code-span">Example</code>은 semantic한 차이가 거의 없다고 문서에 나와있습니다. 문맥에 따라서 사람이 읽기 쉬운 키워드를 고르면 될 듯 합니다. 책에서는 <code class="inline-code-span">Theorem</code>이 수학적 증명에 가깝고, <code class="inline-code-span">Example</code>은 unit test에 가까운 용례로 쓰이는 듯 합니다.</p><p><code class="inline-code-span">Theorem</code>이나 <code class="inline-code-span">Example</code>의 뒤에는 바로 <code class="inline-code-span">Proof</code>가 와서 증명을 제공해야합니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Example</span><span class="color-white"> test_even1</span><span class="color-white">:</span><span class="color-white"> is_even </span><span class="color-gold">2</span> <span class="color-white">=</span><span class="color-white"> true</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> plus_O_n </span><span class="color-white">:</span><span class="color-white"> forall n </span><span class="color-white">:</span><span class="color-white"> nat</span><span class="color-white">,</span> <span class="color-gold">0</span> <span class="color-white">+</span><span class="color-white"> n </span><span class="color-white">=</span><span class="color-white"> n</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(7)">Copy</button></pre><p>위의 예시들은 책에서 쓰인 용례들을 그대로 갖고 온 것입니다. 책에서 <code class="inline-code-span">Theorem</code>과 <code class="inline-code-span">Example</code>을 어떤 뉘앙스로 사용하는지 확인하실 수 있습니다. 또한 저 용례에서 <code class="inline-code-span">Example</code>과 <code class="inline-code-span">Theorem</code>을 뒤바꿔서 실행해도 문제없이 돌아갑니다.</p><p><code class="inline-code-span">Lemma</code>, <code class="inline-code-span">Fact</code>, <code class="inline-code-span">Remark</code> 등의 키워드들도 위 키워드들과 거의 비슷한 역할을 합니다.</p><ul><li><a href="https://stackoverflow.com/questions/60101214/what-is-the-difference-between-definitions-and-theorems">stackoverflow</a></li><li><a href="#ex1">예시1</a></li><li><a href="Chap1-2.html#ex1">예시2</a></li><li><a href="#ex2">예시3</a></li></ul></div><div class="box"><p><a id="keywordintros"></a><a id="keywordintro"></a></p><p><span class="size-giant">intros, intro</span></p><p><code class="inline-code-span">intro</code> 키워드에 복수형 s가 붙은 형태입니다. 원래 <code class="inline-code-span">intro</code> 키워드는 한번에 하나만 <em>introduce</em> 할 수 있지만 <code class="inline-code-span">intros</code>는 여러 개를 introduce 할 수 있습니다. 여기서 둘이 동시에 설명하겠습니다.</p><p><code class="inline-code-span">intro</code> 키워드는 Theorem에 있는 식들을 context에 넣습니다. Theorem에 <code class="inline-code-span">forall n, m: nat</code>이 있을 때 <code class="inline-code-span">intros n m</code>을 하면 <code class="inline-code-span">n</code>과 <code class="inline-code-span">m</code>이 context에 들어가고, 그때부터 증명과정에서 <code class="inline-code-span">n</code>과 <code class="inline-code-span">m</code>을 사용할 수 있게 됩니다. <code class="inline-code-span">n</code>과 <code class="inline-code-span">m</code>이 아닌 다른 이름을 사용해도 상관없습니다. <code class="inline-code-span">intros</code> 키워드는 이름을 기준으로 context에 넣는게 아니고, 앞에서부터 순서대로 context에 집어넣습니다. 즉, <code class="inline-code-span">forall n, m : nat</code>에다가 <code class="inline-code-span">intros a b</code>를 하면 <code class="inline-code-span">n</code>, <code class="inline-code-span">m</code>이 순서대로 <code class="inline-code-span">a</code>, <code class="inline-code-span">b</code>라는 이름으로 context에 들어갑니다.</p><p><code class="inline-code-span">n = m -&gt; n + n = m + m</code> 같은 경우, <code class="inline-code-span">n = m</code>이라는 명제도 context에 넣어야 증명이 가능합니다. 저 상황에서 <code class="inline-code-span">intros H</code>를 하면 context에 <code class="inline-code-span">H: n = m</code>이 들어간 것을 확인할 수 있습니다. 그럼 <code class="inline-code-span">rewrite H</code>와 같은 방식으로 <code class="inline-code-span">n = m</code>을 증명에 사용할 수 있습니다.</p><div class="box"><p>Todo</p><p><code class="inline-code-span">intros</code>를 하면 <code class="inline-code-span">forall</code>을 없어지고 context에 들어온다는 설명을 봤는데, <code class="inline-code-span">forall</code>이 없어진다는게 정확히 무슨 의미인지 아직 모르겠습니다.</p></div><ul><li><a href="https://stackoverflow.com/questions/70482977/understanding-the-intros-keyword-work-in-coq">stackoverflow</a></li><li><a href="https://coq.inria.fr/refman/proof-engine/tactics.html#coq:tacv.intros">공식 문서 참고</a></li><li><a href="#ex1">예시1</a></li><li><a href="#ex2">예시2</a></li></ul></div><div class="box"><p><a id="keywordreflexivity"></a></p><p><span class="size-giant">reflexivity</span></p><p>등식의 양변이 동일한 값을 갖고 있는지 확인합니다. goal에서 등식의 양변이 동일한 값을 가질 경우 증명이 끝납니다.</p><ul><li><a href="#ex1">예시1</a></li></ul></div><div class="box"><p><a id="keywordrewrite"></a></p><p><span class="size-giant">rewrite</span></p><p><code class="inline-code-span">H: n = m</code>을 가지고 <code class="inline-code-span">rewrite -&gt; H.</code>를 할 경우 theorem 안의 모든 <code class="inline-code-span">n</code>을 <code class="inline-code-span">m</code>으로 rewrite합니다. 화살표를 반대방향으로 (<code class="inline-code-span">&lt;-</code>) 쓸 경우 <code class="inline-code-span">m</code>을 <code class="inline-code-span">n</code>으로 rewrite합니다. 화살표는 생략가능하며, 생략할 경우 <code class="inline-code-span">-&gt;</code>의 방향으로 적용됩니다.</p><ul><li><a href="#ex2">예시1</a></li></ul></div><div class="box"><p><a id="keywordsimpl"></a></p><p><span class="size-giant">simpl</span></p><p>등식의 양변을 간단한 형태로 정리합니다.</p><p>Coq 인터프리터에 <code class="inline-code-span">forall n : nat, 1 + n = S n</code>을 넣고 <code class="inline-code-span">simpl</code> tactic을 통과시키면 goal에 있던 <code class="inline-code-span">1 + n = S n</code>이 <code class="inline-code-span">S n = S n</code>으로 바뀌는 것을 확인할 수 있습니다. 덧셈함수의 <a href="Chap1-2.html#functionnatplus">정의</a>에 따르면 <code class="inline-code-span">(plus 1 n)</code>은 <code class="inline-code-span">(S (plus 0 n))</code>이고 그 값은 다시 <code class="inline-code-span">(S n)</code>이 되죠? Coq도 이 과정을 동일하게 거쳐서 <code class="inline-code-span">1 + n</code>을 <code class="inline-code-span">S n</code>으로 고칩니다.</p><p>함수의 정의에 값을 그대로 넣어서 간단한 형태로 정리한다는게 중요합니다. 만약 <code class="inline-code-span">1 + n = S n</code>이 아니라 <code class="inline-code-span">n + 1 = S n</code>을 넣고 <code class="inline-code-span">simpl</code>을 통과시키면 Coq는 아무것도 하지 못합니다. 정의를 이용해서는 첫번째 인수만 줄일 수 있거든요.</p><ul><li><a href="#ex1">예시1</a></li></ul></div><div class="box"><p><a id="keywordadmitted"></a></p><p><span class="size-giant">Admitted</span></p><p>원래는 <code class="inline-code-span">Theorem</code> 뒤에 바로 <code class="inline-code-span">Proof</code>가 나와서 <code class="inline-code-span">Qed</code>로 마무리를 해야하는데, 증명을 나중으로 미루고 싶을 경우 <code class="inline-code-span">Admitted</code> 키워드를 사용할 수 있습니다. <code class="inline-code-span">Admitted</code>를 이용해서 증명한 <code class="inline-code-span">Theorem</code>도 다른 증명에 사용 가능합니다. 다만, 그렇게 증명할 경우 Coq는 증명이 불완전하다고 투덜거립니다.</p></div><div class="box"><p><a id="keywordabort"></a></p><p><span class="size-giant">Abort</span></p><p>증명을 그만둡니다. <code class="inline-code-span">Admitted</code>를 이용해서 마무리한 정리는 다른 증명에 사용할 수 있지만, <code class="inline-code-span">Abort</code>로 마무리한 정리는 다른 증명에 사용할 수 없습니다.</p></div><hr/><div class="align-center"><p><a href="index.html">메인으로 돌아가기</a></p></div><div class="align-left"><p>&lt;&lt; <a href="Chap1-2.html">Chap1-2. Natrual Numbers</a></p></div><div class="align-right"><p><a href="Chap2-1.html">Chap2-1. Proofs by Induction</a> &gt;&gt;</p></div><script>/*<![CDATA[*/
const fenced_code_block_contents = ["Theorem plus_O_n : forall n : nat, 0 + n = n.\nProof.\n  intros n.\n  simpl.\n  reflexivity.\n  Qed.", "Theorem plus_id_example : forall n m:nat,\n  n = m ->\n  n + n = m + m.\n\nProof.\n  intros n m.    (*{- n m : nat -}*)\n  intros H.      (*{- H: n = m -}*)\n  rewrite -> H.  (*{- `n + n = m + m`이 `m + m = m + m`이 됩니다. -}*)\n  reflexivity.   (*{- 양변이 같음을 확인합니다. -}*)\n  Qed.", "Theorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false.", "Proof.\n  intros n.\n  destruct n as [ | n'] eqn:E.\n  - (*{- n = 0 -}*)\n    reflexivity.\n  - (*{- n = S n' -}*)\n    reflexivity.\n  Qed.", "Theorem negb_involutive : forall b : bool,\n  negb (negb b) = b.\nProof.\n  intros b.\n  destruct b eqn: E.\n  - (*{- b = true -}*)\n    reflexivity.\n  - (*{- b = false -}*)\n    reflexivity.\n  Qed.", "", "Proof.\n  intros b c.\n  destruct b eqn: Eb.\n  - (*{- b = true -}*)\n    destruct c eqn: Ec.\n    + (*{- c = true -}*)\n      reflexivity.\n    + (*{- c = false -}*)\n      reflexivity.\n  - (*{- b = false -}*)\n    destruct c eqn: Ec.\n    + (*{- c = true -}*)\n      reflexivity.\n    + (*{- c = false -}*)\n      reflexivity.\nQed.", "Example test_even1: is_even 2 = true.\nTheorem plus_O_n : forall n : nat, 0 + n = n."];

function copy_code_to_clipboard(index) {
    navigator.clipboard.writeText(fenced_code_block_contents[index]);
}/*]]>*/</script>
        <a id="bottom"></a>
    </article>




    <footer class="markdown">
<p><br/></p><p><br/></p><hr/><div class="align-center"><p>2021 ~ 2023 &copy; Baehyunsol</p></div>
    </footer>


    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
    
    
    <script src="header.js"></script>
    
<script src="collapsible_tables.js"></script></body>

</html>