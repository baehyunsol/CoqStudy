<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>Chap1-3</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> 
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/><link href="header.css" rel="stylesheet"/><link href="footer.css" rel="stylesheet"/>
    
</head>

<body>


    <header>
<p><a href="index.html">Home</a></p>
    </header>



    <nav>
<p><a id="settingsopenbutton">&#9728;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p><div id="settingsmenu"> <a id="settingsclosebutton">&#10006;</a> <a id="changethemebutton">Set Light Theme</a> <a id="loosepaddingbutton">&#8592; &#8594;</a> <a id="tightpaddingbutton">&#8594; &#8592;</a> </div></p></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<table><thead id="table-collapse-toggle-0" class="collapsible collapsed" onclick="collapse_table('0')"><tr><th> Table of Contents </th></tr></thead><tbody id="collapsible-table-0" class="invisible"><tr><td><div class="toc"><ol type="1"><li><a href="#proofs">Proofs</a><ol type="1"><li><a href="#by-simplification">By Simplification</a></li><li><a href="#by-rewriting">By Rewriting</a></li><li><a href="#by-case-analysis">By Case Analysis</a></li><li><a href="#키워드-정리">키워드 정리</a></li></ol></li></ol></div></td></tr></tbody></table><h1 id="proofs">Proofs</h1><p>Coq는 <em>theorem prover</em>입니다. 즉, 증명이 핵심입니다. 아쉽게도 Coq가 증명을 대신 해주지는 않습니다. 사람이 theorem을 입력하고 그걸 증명하는데 사용할 전략들을 알려주면 Coq가 증명을 <em>보조</em>해줍니다. 이번 챕터에서는 증명의 전략들을 알아보겠습니다.</p><h2 id="by-simplification">By Simplification</h2><p><a id="ex1"></a></p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> plus_O_n </span><span class="color-white">:</span><span class="color-white"> forall n </span><span class="color-white">:</span><span class="color-white"> nat</span><span class="color-white">,</span><span class="color-white"> </span><span class="color-gold">0</span><span class="color-white"> </span><span class="color-white">+</span><span class="color-white"> n </span><span class="color-white">=</span><span class="color-white"> n</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  intros n</span><span class="color-white">.</span><span class="color-white"> simpl</span><span class="color-white">.</span><span class="color-white"> reflexivity</span><span class="color-white">.</span><span class="color-white"> </span><span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(0)">Copy</button></pre><p>위의 코드는 Coq를 이용한 간단한 증명과정을 나타냅니다.</p><ol type="1"><li>먼저, <code class="inline-code-span">Theorem</code> 키워드를 이용해서 정리를 정의합니다.<ul><li>여기서는 <code class="inline-code-span">plus_O_n</code>이라는 정리를 정의했습니다.</li><li>정리의 내용은 &apos;<em>모든 자연수 n에 대해서 0 + n = n이다</em>&apos;입니다.</li></ul></li><li>바로 다음에 <code class="inline-code-span">Proof</code> 키워드를 이용해서 <code class="inline-code-span">plus_O_n</code>을 증명합니다.</li><li><code class="inline-code-span">Proof</code> 키워드 다음에 증명에 쓰일 tactic이 쭉 나오고, <code class="inline-code-span">Qed</code> 키워드를 이용해서 증명이 끝났음을 선언합니다.</li></ol><p>각 tactic이 무슨 역할을 하는지는 아래의 <a href="#키워드-정리">키워드 정리</a>에서 자세하게 설명하겠습니다.</p><h2 id="by-rewriting">By Rewriting</h2><p><a id="ex2"></a></p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> plus_id_example </span><span class="color-white">:</span><span class="color-white"> forall n m</span><span class="color-white">:</span><span class="color-white">nat</span><span class="color-white">,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  n </span><span class="color-white">=</span><span class="color-white"> m </span><span class="color-white">-&gt;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  n </span><span class="color-white">+</span><span class="color-white"> n </span><span class="color-white">=</span><span class="color-white"> m </span><span class="color-white">+</span><span class="color-white"> m</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  intros n m</span><span class="color-white">.</span><span class="color-white">    (*</span><span class="color-gray">{-</span><span class="color-gray"> n m : nat </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">  intros </span><span class="color-gold">H</span><span class="color-white">.</span><span class="color-white">      (*</span><span class="color-gray">{-</span><span class="color-gray"> H: n = m </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">  rewrite </span><span class="color-white">-&gt;</span><span class="color-white"> </span><span class="color-gold">H</span><span class="color-white">.</span><span class="color-white">  (*</span><span class="color-gray">{-</span><span class="color-gray"> `n + n = m + m`이 `m + m = m + m`이 됩니다. </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">  reflexivity</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> 양변이 같음을 확인합니다. </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(1)">Copy</button></pre><p>이번에는 theorem의 형태가 조금 바뀌었죠? <code class="inline-code-span">-&gt;</code> 기호가 들어갔습니다. <code class="inline-code-span">-&gt;</code> 기호는 <code class="inline-code-span">p이면 q이다</code>의 의미를 나타내기 위해 쓰이며, <em>implies</em>라고 읽습니다.</p><p><code class="inline-code-span">intros</code>도 2번 등장합니다. 첫번째 <code class="inline-code-span">intros n m</code>은 Theorem 속에 <code class="inline-code-span">forall n m</code>으로 돼 있는 부분을 context에 집어넣고, 두번째 <code class="inline-code-span">intros H</code>는 <code class="inline-code-span">p이면 q이다</code>의 <code class="inline-code-span">p</code>를 context에 집어넣습니다. 즉, context 안에는 <code class="inline-code-span">H</code>라는 hypothesis가 있으며, <code class="inline-code-span">H</code>의 내용은 <code class="inline-code-span">H: n = m</code>입니다.</p><h2 id="by-case-analysis">By Case Analysis</h2><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> plus_1_neq_0 </span><span class="color-white">:</span><span class="color-white"> forall n </span><span class="color-white">:</span><span class="color-white"> nat</span><span class="color-white">,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  (n </span><span class="color-white">+</span><span class="color-white"> </span><span class="color-gold">1</span><span class="color-white">) </span><span class="color-white">=?</span><span class="color-white"> </span><span class="color-gold">0</span><span class="color-white"> </span><span class="color-white">=</span><span class="color-white"> false</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(2)">Copy</button></pre><p>위와 같은 theorem을 생각해보겠습니다.</p><h2 id="키워드-정리">키워드 정리</h2><div class="box"><p><a id="keywordtheorem"></a> <a id="keywordexample"></a></p><p><span class="size-giant">Theorem, Example</span></p><p>참이라고 주장하고 싶은 정리를 선언하는데 쓰입니다. <code class="inline-code-span">Theorem</code>과 <code class="inline-code-span">Example</code>은 semantic한 차이가 거의 없다고 문서에 나와있습니다. 문맥에 따라서 사람이 읽기 쉬운 키워드를 고르면 될 듯 합니다. 책에서는 <code class="inline-code-span">Theorem</code>이 수학적 증명에 가깝고, <code class="inline-code-span">Example</code>은 unit test에 가까운 용례로 쓰이는 듯 합니다.</p><p><code class="inline-code-span">Theorem</code>이나 <code class="inline-code-span">Example</code>의 뒤에는 바로 <code class="inline-code-span">Proof</code>가 와서 증명을 제공해야합니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Example</span><span class="color-white"> test_even1</span><span class="color-white">:</span><span class="color-white"> is_even </span><span class="color-gold">2</span><span class="color-white"> </span><span class="color-white">=</span><span class="color-white"> true</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> plus_O_n </span><span class="color-white">:</span><span class="color-white"> forall n </span><span class="color-white">:</span><span class="color-white"> nat</span><span class="color-white">,</span><span class="color-white"> </span><span class="color-gold">0</span><span class="color-white"> </span><span class="color-white">+</span><span class="color-white"> n </span><span class="color-white">=</span><span class="color-white"> n</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(3)">Copy</button></pre><p>위의 예시들은 책에서 쓰인 용례들을 그대로 갖고 온 것입니다. 책에서 <code class="inline-code-span">Theorem</code>과 <code class="inline-code-span">Example</code>을 어떤 뉘앙스로 사용하는지 확인하실 수 있습니다. 또한 저 용례에서 <code class="inline-code-span">Example</code>과 <code class="inline-code-span">Theorem</code>을 뒤바꿔서 실행해도 문제없이 돌아갑니다.</p><p><code class="inline-code-span">Lemma</code>, <code class="inline-code-span">Fact</code>, <code class="inline-code-span">Remark</code> 등의 키워드들도 위 키워드들과 거의 비슷한 역할을 합니다.</p><ul><li><a href="https://stackoverflow.com/questions/60101214/what-is-the-difference-between-definitions-and-theorems">stackoverflow</a></li><li><a href="#ex1">예시1</a></li><li><a href="Chap1-2.html#ex1">예시2</a></li><li><a href="#ex2">예시3</a></li></ul></div><div class="box"><p><a id="keywordintros"></a><a id="keywordintro"></a></p><p><span class="size-giant">intros, intro</span></p><p><code class="inline-code-span">intro</code> 키워드에 복수형 s가 붙은 형태입니다. 원래 <code class="inline-code-span">intro</code> 키워드는 한번에 하나만 <em>introduce</em> 할 수 있지만 <code class="inline-code-span">intros</code>는 여러 개를 introduce 할 수 있습니다. 여기서 둘이 동시에 설명하겠습니다.</p><p><code class="inline-code-span">intro</code> 키워드는 Theorem에 있는 식들을 context에 넣습니다. Theorem에 <code class="inline-code-span">forall n, m: nat</code>이 있을 때 <code class="inline-code-span">intros n m</code>을 하면 <code class="inline-code-span">n</code>과 <code class="inline-code-span">m</code>이 context에 들어가고, 그때부터 증명과정에서 <code class="inline-code-span">n</code>과 <code class="inline-code-span">m</code>을 사용할 수 있게 됩니다. <code class="inline-code-span">n</code>과 <code class="inline-code-span">m</code>이 아닌 다른 이름을 사용해도 상관없습니다. <code class="inline-code-span">intros</code> 키워드는 이름을 기준으로 context에 넣는게 아니고, 앞에서부터 순서대로 context에 집어넣습니다. 즉, <code class="inline-code-span">forall n, m : nat</code>에다가 <code class="inline-code-span">intros a b</code>를 하면 <code class="inline-code-span">n</code>, <code class="inline-code-span">m</code>이 순서대로 <code class="inline-code-span">a</code>, <code class="inline-code-span">b</code>라는 이름으로 context에 들어갑니다.</p><p><code class="inline-code-span">n = m -&gt; n + n = m + m</code> 같은 경우, <code class="inline-code-span">n = m</code>이라는 명제도 context에 넣어야 증명이 가능합니다. 저 상황에서 <code class="inline-code-span">intros H</code>를 하면 context에 <code class="inline-code-span">H: n = m</code>이 들어간 것을 확인할 수 있습니다. 그럼 <code class="inline-code-span">rewrite H</code>와 같은 방식으로 <code class="inline-code-span">n = m</code>을 증명에 사용할 수 있습니다.</p><div class="box"><p><code class="inline-code-span">intros</code>를 하면 <code class="inline-code-span">forall</code>을 없어지고 context에 들어온다는 설명을 봤는데, <code class="inline-code-span">forall</code>이 없어진다는게 정확히 무슨 의미인지 아직 모르겠습니다.</p></div><div class="box"><p>Context에 넣는다는 것도 정확히 무슨 의미인지 모르겠습니다. 증명에 쓰려면 이름을 붙여야 해서 넣는 것 같은데, 일단은 name scope의 의미로만 이해해야겠습니다.</p></div><ul><li><a href="https://stackoverflow.com/questions/70482977/understanding-the-intros-keyword-work-in-coq">stackoverflow</a></li><li><a href="https://coq.inria.fr/refman/proof-engine/tactics.html#coq:tacv.intros">공식 문서 참고</a></li><li><a href="#ex1">예시1</a></li><li><a href="#ex2">예시2</a></li></ul></div><div class="box"><p><a id="keywordreflexivity"></a></p><p><span class="size-giant">reflexivity</span></p><p>등식의 양변이 동일한 값을 갖고 있는지 확인합니다.</p><ul><li><a href="#ex1">예시1</a></li></ul></div><div class="box"><p><a id="keywordrewrite"></a></p><p><span class="size-giant">rewrite</span></p><p><code class="inline-code-span">H: n = m</code>을 가지고 <code class="inline-code-span">rewrite -&gt; H.</code>를 할 경우 theorem 안의 모든 <code class="inline-code-span">n</code>을 <code class="inline-code-span">m</code>으로 rewrite합니다. 화살표를 반대방향으로 (<code class="inline-code-span">&lt;-</code>) 쓸 경우 <code class="inline-code-span">m</code>을 <code class="inline-code-span">n</code>으로 rewrite합니다. 화살표는 생략가능하며, 생략할 경우 <code class="inline-code-span">-&gt;</code>의 방향으로 적용됩니다.</p><ul><li><a href="#ex2">예시1</a></li></ul></div><div class="box"><p><a id="keywordsimpl"></a></p><p><span class="size-giant">simpl</span></p><p>등식의 양변을 간단한 형태로 정리합니다.</p><p>Coq 인터프리터에 <code class="inline-code-span">forall n : nat, 1 + n = S n</code>을 넣고 <code class="inline-code-span">simpl</code> tactic을 통과시키면 goal에 있던 <code class="inline-code-span">1 + n = S n</code>이 <code class="inline-code-span">S n = S n</code>으로 바뀌는 것을 확인할 수 있습니다. 덧셈함수의 <a href="Chap1-2.html#functionnatplus">정의</a>에 따르면 <code class="inline-code-span">(plus 1 n)</code>은 <code class="inline-code-span">(S (plus 0 n))</code>이고 그 값은 다시 <code class="inline-code-span">(S n)</code>이 되죠? Coq도 이 과정을 동일하게 거쳐서 <code class="inline-code-span">1 + n</code>을 <code class="inline-code-span">S n</code>으로 고칩니다.</p><p>함수의 정의에 값을 그대로 넣어서 간단한 형태로 정리한다는게 중요합니다. 만약 <code class="inline-code-span">1 + n = S n</code>이 아니라 <code class="inline-code-span">n + 1 = S n</code>을 넣고 <code class="inline-code-span">simpl</code>을 통과시키면 Coq는 아무것도 하지 못합니다. 정의를 이용해서는 첫번째 인수만 줄일 수 있거든요.</p><ul><li><a href="#ex1">예시1</a></li></ul></div><hr/><p>아직 정리 안된 친구들!</p><div class="box"><p>Admitted</p><p>원래는 <code class="inline-code-span">Theorem</code> 뒤에 바로 <code class="inline-code-span">Proof</code>가 나와서 <code class="inline-code-span">Qed</code>로 마무리를 해야하는데, 증명을 나중으로 미루고 싶을 경우 <code class="inline-code-span">Admitted</code> 키워드를 사용할 수 있습니다.</p></div><hr/><div class="align-center"><p><a href="index.html">메인으로 돌아가기</a></p></div><div class="align-left"><p>&lt;&lt; <a href="Chap1-2.html">Chap1-2. Natrual Numbers</a></p></div><div class="align-right"><p>다음 글이 없습니다.</p></div><script>/*<![CDATA[*/
const fenced_code_block_contents = ["Theorem plus_O_n : forall n : nat, 0 + n = n.\nProof.\n  intros n. simpl. reflexivity. Qed.", "Theorem plus_id_example : forall n m:nat,\n  n = m ->\n  n + n = m + m.\n\nProof.\n  intros n m.    (*{- n m : nat -}*)\n  intros H.      (*{- H: n = m -}*)\n  rewrite -> H.  (*{- `n + n = m + m`이 `m + m = m + m`이 됩니다. -}*)\n  reflexivity.   (*{- 양변이 같음을 확인합니다. -}*)\n  Qed.", "Theorem plus_1_neq_0 : forall n : nat,\n  (n + 1) =? 0 = false.", "Example test_even1: is_even 2 = true.\nTheorem plus_O_n : forall n : nat, 0 + n = n."];

function copy_code_to_clipboard(index) {
    navigator.clipboard.writeText(fenced_code_block_contents[index]);
}/*]]>*/</script>
        <a id="bottom"></a>
    </article>




    <footer class="markdown">
<p><br/></p><p><br/></p><hr/><div class="align-center"><p>2021 ~ 2022 (c) Baehyunsol</p><p>Powered by <a href="https://github.com/baehyunsol/MDxt">MDxt</a></p></div>
    </footer>


    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
<script src="collapsible_tables.js"></script></body>

</html>