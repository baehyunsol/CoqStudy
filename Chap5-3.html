<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>Chap5-3</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> 
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/><link href="header.css" rel="stylesheet"/><link href="footer.css" rel="stylesheet"/>
    
</head>

<body>


    <header>
<p><a href="index.html">Home</a></p>
    </header>



    <nav>
<p><a id="settingsopenbutton">&#9728;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p><div id="settingsmenu"> <a id="settingsclosebutton">&#10006;</a> <a id="changethemebutton">Set Light Theme</a> <a id="loosepaddingbutton">&#8592; &#8594;</a> <a id="tightpaddingbutton">&#8594; &#8592;</a> </div></p></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<table><thead id="table-collapse-toggle-0" class="collapsible collapsed" onclick="collapse_table('0')"><tr><th> Table of Contents </th></tr></thead><tbody id="collapsible-table-0" class="invisible"><tr><td><div class="toc"><ol type="1"><li><a href="#more-tactics">More tactics</a><ol type="1"><li><a href="#tactics-on-hypothesis">Tactics on Hypothesis</a></li><li><a href="#varying-the-induction-hypothesis">Varying the Induction Hypothesis</a></li><li><a href="#unfold">unfold</a></li><li><a href="#destruct-on-compound-expressions">destruct on compound expressions</a></li></ol></li></ol></div></td></tr></tbody></table><h1 id="more-tactics">More tactics</h1><h2 id="tactics-on-hypothesis">Tactics on Hypothesis</h2><p><a id="keywordin"></a></p><p>Context 안에 있는 가정들을 대상으로 tactic을 사용하려면 어떻게 해야할까요? Context 안에 <code class="inline-code-span">H: m = n</code>가 있는데 저걸 <code class="inline-code-span">H: n = m</code>으로 바꾸려면 어떻게 해야할까요? <code class="inline-code-span">in</code>이라는 키워드를 쓰면 됩니다. 아래의 예시를 보겠습니다.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> ridiculous </span><span class="color-white">:</span><span class="color-white"> forall (n m p q </span><span class="color-white">:</span><span class="color-white"> nat)</span><span class="color-white">,</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  (n </span><span class="color-white">=</span><span class="color-white"> m </span><span class="color-white">-&gt;</span><span class="color-white"> p </span><span class="color-white">=</span><span class="color-white"> q) </span><span class="color-white">-&gt;</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  m </span><span class="color-white">=</span><span class="color-white"> n </span><span class="color-white">-&gt;</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  q </span><span class="color-white">=</span><span class="color-white"> p</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  intros n m p q </span><span class="color-gold">EQ</span> <span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">  symmetry </span><span class="color-violet">in</span> <span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">  apply </span><span class="color-gold">EQ</span> <span class="color-violet">in</span> <span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">  symmetry </span><span class="color-violet">in</span> <span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">  apply </span><span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(0)">Copy</button></pre><p>7번 줄의 <code class="inline-code-span">symmetry in H</code>는 <code class="inline-code-span">H: m = n</code>을 <code class="inline-code-span">H: n = m</code>으로 바꿉니다.</p><h2 id="varying-the-induction-hypothesis">Varying the Induction Hypothesis</h2><p>TODO: 나중에 추가 ㄱㄱ</p><p>이 안에 <code class="inline-code-span">generalize dependent</code>도 나오는데 그것도 추가 ㄱㄱ</p><h2 id="unfold">unfold</h2><p><a id="keywordunfold"></a></p><p>간단한 예시로 시작하겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> square (n </span><span class="color-white">:</span><span class="color-white"> nat) </span><span class="color-white">:=</span><span class="color-white"> n * n</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> square_mult </span><span class="color-white">:</span><span class="color-white"> forall (n m </span><span class="color-white">:</span><span class="color-white"> nat)</span><span class="color-white">,</span><span class="color-white"> square (n * m) </span><span class="color-white">=</span><span class="color-white"> square n * square m</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(1)">Copy</button></pre><p>눈으로 보기에는 당연해 보이는 위 예제를 Coq로 증명하려면 생각보다 쉽지 않습니다. <code class="inline-code-span">simpl</code>을 쓰더라도 <code class="inline-code-span">square</code> 함수의 내부를 건드리지 않기 때문에 아무 일도 일어나지 않습니다. 이럴 때 사용하는게 <code class="inline-code-span">unfold</code>입니다. 함수 inlining이라고 생각하면 비슷합니다.<span class="footnote-ref" id="footnote-ref-0"><a href="#footnote-cite-0">[0]</a></span></p><p><code class="inline-code-span">unfold square</code>는 <code class="inline-code-span">square n</code>을 <code class="inline-code-span">n * n</code>으로 바꿔줍니다. 즉, 위의 식이 <code class="inline-code-span">n * m * (n * m) = n * n * (m * m)</code>가 됩니다. 이러면 적용할 수 있는 tactic이 아주 많아집니다.</p><p>물론 <code class="inline-code-span">simpl</code>이나 <code class="inline-code-span">reflexivity</code>, <code class="inline-code-span">apply</code> 등도 어느정도의 unfolding을 합니다. 하지만 적용이 될 때도 있고 안 될 때도 있습니다. 그에반해 <code class="inline-code-span">unfold</code>는 모든 상황에서 단순무식하게 식을 unfolding합니다.</p><h2 id="destruct-on-compound-expressions">destruct on compound expressions</h2><p><a id="keyworddestruct"></a></p><p><a href="Chap1-3.html#keyworddestruct">이전</a>에 봤던 <code class="inline-code-span">destruct</code>는 특정 값을 쪼갰습니다. 예를 들어 어떤 boolean <code class="inline-code-span">b</code>를 <code class="inline-code-span">destruct b</code>하면 <code class="inline-code-span">b</code>가 <code class="inline-code-span">true</code>인 경우와 <code class="inline-code-span">false</code>인 경우로 나눠집니다. 값을 쪼개는게 아니라 식을 쪼갤 수도 있을까요? 아래의 예시를 보겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> compound_false (n </span><span class="color-white">:</span><span class="color-white"> nat) </span><span class="color-white">:</span><span class="color-white"> bool </span><span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">  <span class="color-violet">if</span><span class="color-white"> n </span><span class="color-white">=?</span> <span class="color-gold">3</span> <span class="color-violet">then</span><span class="color-white"> false
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">  <span class="color-violet">else</span> <span class="color-violet">if</span><span class="color-white"> n </span><span class="color-white">=?</span> <span class="color-gold">5</span> <span class="color-violet">then</span><span class="color-white"> false
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">  <span class="color-violet">else</span><span class="color-white"> false</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> compound_false_false </span><span class="color-white">:</span><span class="color-white"> forall (n </span><span class="color-white">:</span><span class="color-white"> nat)</span><span class="color-white">,</span><span class="color-white"> compound_false n </span><span class="color-white">=</span><span class="color-white"> false</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(2)">Copy</button></pre><p>위에서 정의한 <code class="inline-code-span">compound_false</code>는 항상 <code class="inline-code-span">false</code>입니다. 사람 눈으로 보기엔 그게 자명하지만 Coq가 봐도 그럴까요? 아쉽게도 그렇지 않습니다. Coq에게는 <code class="inline-code-span">destruct</code>를 이용해서 <code class="inline-code-span">n</code>이 3, 5, 나머지인 경우로 나눠줘야합니다. 아래처럼 말이죠.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code">Proof.</span></span>
<span class="code-fence-row"><span class="code-fence-code">  intros n.</span></span>
<span class="code-fence-row"><span class="code-fence-code">  unfold compound_false.</span></span>
<span class="code-fence-row"><span class="code-fence-code">  destruct (n =? 3).</span></span>
<span class="code-fence-row"><span class="code-fence-code">  - (*{- n =? 3 = true -}*)</span></span>
<span class="code-fence-row"><span class="code-fence-code">    reflexivity.</span></span>
<span class="code-fence-row"><span class="code-fence-code">  - (*{- n =? 3 = false -}*)</span></span>
<span class="code-fence-row"><span class="code-fence-code">    destruct (n =? 5).</span></span>
<span class="code-fence-row"><span class="code-fence-code">    + (*{- n =? 5 = true -}*)</span></span>
<span class="code-fence-row"><span class="code-fence-code">      reflexivity.</span></span>
<span class="code-fence-row"><span class="code-fence-code">    + (*{- n =? 5 = false -}*)</span></span>
<span class="code-fence-row"><span class="code-fence-code">      reflexivity.</span></span>
<span class="code-fence-row"><span class="code-fence-code">  Qed.</span></span>
</code></pre><p>위의 식은 <code class="inline-code-span">n</code>에다가 3을 대입하는게 아니고 <code class="inline-code-span">n =? 3</code>에다가 <code class="inline-code-span">true</code>를 대입합니다. 그러면 if문이 통째로 날아가서 <code class="inline-code-span">false</code>와 <code class="inline-code-span">if n =? 5 then ...</code>으로 쪼개집니다. 그렇게되면 저희가 증명하려는 식도 <code class="inline-code-span">false = false</code>의 형태가 되어서 <code class="inline-code-span">reflexivity</code>만으로 증명이 가능해집니다.</p><hr/><div class="align-center"><p><a href="index.html">메인으로 돌아가기</a></p></div><div class="align-left"><p>&lt;&lt; <a href="Chap5-2.html">Chap5-2. Injective and Disjoint</a></p></div><div class="align-right"><p><a href="Chap6-1.html">Chap6-1. 가제</a> &gt;&gt;</p></div><hr class="footnote-hr"/><div class="mdxt-footnote-cites"><p><div class="footnote-cite"><a id="footnote-cite-0"></a>0. <a href="#footnote-ref-0"> [0]</a> 제 개인적인 의견입니다.</div></p></div><script>/*<![CDATA[*/
const fenced_code_block_contents = ["Theorem ridiculous : forall (n m p q : nat),\n  (n = m -> p = q) ->\n  m = n ->\n  q = p.\nProof.\n  intros n m p q EQ H.\n  symmetry in H.\n  apply EQ in H.\n  symmetry in H.\n  apply H.\n  Qed.", "Definition square (n : nat) := n * n.\n\nTheorem square_mult : forall (n m : nat), square (n * m) = square n * square m.", "Definition compound_false (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false.\n\nTheorem compound_false_false : forall (n : nat), compound_false n = false."];

function copy_code_to_clipboard(index) {
    navigator.clipboard.writeText(fenced_code_block_contents[index]);
}/*]]>*/</script>
        <a id="bottom"></a>
    </article>




    <footer class="markdown">
<p><br/></p><p><br/></p><hr/><div class="align-center"><p>2021 ~ 2022 (c) Baehyunsol</p></div>
    </footer>


    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
<script src="collapsible_tables.js"></script></body>

</html>