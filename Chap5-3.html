<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>Chap5-3</title>
    
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"/>
    <!--<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> -->
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/><link href="header.css" rel="stylesheet"/>
    
</head>

<body>


    <header>
<p><div class="topmenu deactivated"><a href="index.html">Home</a> <a href="index.html#index-by-chapter">단원별 목차</a> <a href="index.html#index-by-keyword">키워드 목차</a> <a href="Appendix.html">부록</a></div><div class="mobileview"><a id="navbutton">&#9776;</a></div></p>
    </header>



    <nav>
<p><a id="settingsopenbutton">&#9728;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p><div id="settingsmenu"> <a id="settingsclosebutton">&#10006;</a> <a id="changethemebutton">Set Light Theme</a> <a id="growhorizontalbutton">Grow Horizontally</a> <a id="shrinkhorizontalbutton">Shrink Horizontally</a> <a id="growfontbutton">Grow Font</a> <a id="shrinkfontbutton">Shrink Font</a> </div></p></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<table><thead id="table-collapse-toggle-0" class="collapsible collapsed" onclick="collapse_table('0')"><tr><th>목차</th></tr></thead><tbody id="collapsible-table-0" class="invisible"><tr><td><div class="toc"><ol type="1"><li><a href="#more-tactics">More tactics</a><ol type="1"><li><a href="#tactics-on-hypothesis">Tactics on Hypothesis</a></li><li><a href="#varying-the-induction-hypothesis">Varying the Induction Hypothesis</a></li><li><a href="#unfold">unfold</a></li><li><a href="#destruct-on-compound-expressions">destruct on compound expressions</a></li></ol></li></ol></div></td></tr></tbody></table><h1 id="more-tactics">More tactics</h1><h2 id="tactics-on-hypothesis">Tactics on Hypothesis</h2><p><a id="keywordin"></a></p><p>Context 안에 있는 가정들을 대상으로 tactic을 사용하려면 어떻게 해야할까요? Context 안에 <code class="inline-code-span">H: m = n</code>가 있는데 저걸 <code class="inline-code-span">H: n = m</code>으로 바꾸려면 어떻게 해야할까요? <code class="inline-code-span">in</code>이라는 키워드를 쓰면 됩니다. 아래의 예시를 보겠습니다.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> ridiculous </span><span class="color-white">:</span><span class="color-white"> forall (n m p q </span><span class="color-white">:</span><span class="color-white"> nat)</span><span class="color-white">,</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  (n </span><span class="color-white">=</span><span class="color-white"> m </span><span class="color-white">-&gt;</span><span class="color-white"> p </span><span class="color-white">=</span><span class="color-white"> q) </span><span class="color-white">-&gt;</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  m </span><span class="color-white">=</span><span class="color-white"> n </span><span class="color-white">-&gt;</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  q </span><span class="color-white">=</span><span class="color-white"> p</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  intros n m p q </span><span class="color-gold">EQ</span> <span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">  symmetry </span><span class="color-violet">in</span> <span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">  apply </span><span class="color-gold">EQ</span> <span class="color-violet">in</span> <span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">  symmetry </span><span class="color-violet">in</span> <span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">  apply </span><span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(0)">Copy</button></pre><p>7번 줄의 <code class="inline-code-span">symmetry in H</code>는 <code class="inline-code-span">H: m = n</code>을 <code class="inline-code-span">H: n = m</code>으로 바꿉니다.</p><h2 id="varying-the-induction-hypothesis">Varying the Induction Hypothesis</h2><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> double_injective </span><span class="color-white">:</span><span class="color-white"> forall n m</span><span class="color-white">,</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  double n </span><span class="color-white">=</span><span class="color-white"> double m </span><span class="color-white">-&gt;</span><span class="color-white"> n </span><span class="color-white">=</span><span class="color-white"> m</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(1)">Copy</button></pre><p>위의 식을 증명해보겠습니다. 얼핏 보기엔 <code class="inline-code-span">intros n m</code>을 하고 <code class="inline-code-span">n</code>과 <code class="inline-code-span">m</code>에 대해 각각 <code class="inline-code-span">induction</code>을 쓰면 될 것 같지만 그렇지 않습니다. <code class="inline-code-span">n</code>과 <code class="inline-code-span">m</code> 중 <code class="inline-code-span">forall</code>이 하나라도 있어야하는데 그렇지 않아서 의미가 없는 귀납법이 나옵니다. 그걸 해결하기 위해선 둘 중 하나만 <code class="inline-code-span">intros</code>를 한 뒤, 따로 귀납법을 써야합니다. 아래처럼 말이죠.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  intros n m</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  generalize dependent n</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  induction m as [ </span><span class="color-white">|</span><span class="color-white"> m&apos; </span><span class="color-gold">IHm</span><span class="color-white">&apos;]</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> m = 0 </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">    intros n eq</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">    induction n as [ </span><span class="color-white">|</span><span class="color-white"> n&apos; </span><span class="color-gold">IHn</span><span class="color-white">&apos;]</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code">    <span class="color-white">+</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> n = 0 </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">      reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code">    <span class="color-white">+</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> n = S n&apos; </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code"><span class="color-white">      discriminate eq</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> m = S m&apos; </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code"><span class="color-white">    intros n eq</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code"><span class="color-white">    induction n as [ </span><span class="color-white">|</span><span class="color-white"> n&apos; </span><span class="color-gold">IHn</span><span class="color-white">&apos;]</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code">    <span class="color-white">+</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> n = 0 </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code"><span class="color-white">      discriminate eq</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">17</span><span class="code-fence-code">    <span class="color-white">+</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> n = S n&apos; </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">18</span><span class="code-fence-code"><span class="color-white">      injection eq</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">19</span><span class="code-fence-code"><span class="color-white">      intros </span><span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">20</span><span class="code-fence-code"><span class="color-white">      apply </span><span class="color-gold">IHm</span><span class="color-white">&apos; </span><span class="color-violet">in</span> <span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">21</span><span class="code-fence-code"><span class="color-white">      rewrite </span><span class="color-gold">H</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">22</span><span class="code-fence-code"><span class="color-white">      reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">23</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(2)">Copy</button></pre><p><a id="keywordgeneralize"></a></p><p><code class="inline-code-span">generalize dependent n</code>은 context에 있는 <code class="inline-code-span">n</code>을 다시 <code class="inline-code-span">forall n</code>으로 바꿔줍니다. 그 다음 <code class="inline-code-span">induction m</code>을 한 뒤 그 안에서 각각 <code class="inline-code-span">intros n</code>을 했습니다. 이러면 증명이 성공적으로 끝납니다.</p><p>그럼 애초에 <code class="inline-code-span">intros n</code>만 한 다음에 <code class="inline-code-span">n</code>을 가지고 귀납법을 쓰면 되는 거 아니냐고 생각하시는 분들도 계실 겁니다. 사실 저도 그렇게 생각합니다. 이 예시에서는 <code class="inline-code-span">generalize dependent</code>라는 tactic을 소개하기 위해서 굳이 저렇게 한 거 같습니다.</p><h2 id="unfold">unfold</h2><p><a id="keywordunfold"></a></p><p>간단한 예시로 시작하겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> square (n </span><span class="color-white">:</span><span class="color-white"> nat) </span><span class="color-white">:=</span><span class="color-white"> n * n</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> square_mult </span><span class="color-white">:</span><span class="color-white"> forall (n m </span><span class="color-white">:</span><span class="color-white"> nat)</span><span class="color-white">,</span><span class="color-white"> square (n * m) </span><span class="color-white">=</span><span class="color-white"> square n * square m</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(3)">Copy</button></pre><p>눈으로 보기에는 당연해 보이는 위 예제를 Coq로 증명하려면 생각보다 쉽지 않습니다. <code class="inline-code-span">simpl</code>을 쓰더라도 <code class="inline-code-span">square</code> 함수의 내부를 건드리지 않기 때문에 아무 일도 일어나지 않습니다. 이럴 때 사용하는게 <code class="inline-code-span">unfold</code>입니다. 함수 inlining이라고 생각하면 비슷합니다.<span class="footnote-ref" id="footnote-ref-0"><a href="#footnote-cite-0">[0]</a></span></p><p><code class="inline-code-span">unfold square</code>는 <code class="inline-code-span">square n</code>을 <code class="inline-code-span">n * n</code>으로 바꿔줍니다. 즉, 위의 식이 <code class="inline-code-span">n * m * (n * m) = n * n * (m * m)</code>가 됩니다. 이러면 적용할 수 있는 tactic이 아주 많아집니다.</p><p>물론 <code class="inline-code-span">simpl</code>이나 <code class="inline-code-span">reflexivity</code>, <code class="inline-code-span">apply</code> 등도 어느정도의 unfolding을 합니다. 하지만 적용이 될 때도 있고 안 될 때도 있습니다. 그에반해 <code class="inline-code-span">unfold</code>는 모든 상황에서 단순무식하게 식을 unfolding합니다.</p><div class="box"><p>Todo</p><p><code class="inline-code-span">simpl</code>과 <code class="inline-code-span">unfold</code>는 정확히 어떤 차이가 있을까요...</p></div><h2 id="destruct-on-compound-expressions">destruct on compound expressions</h2><p><a id="keyworddestruct"></a></p><p><a href="Chap1-3.html#keyworddestruct">이전</a>에 봤던 <code class="inline-code-span">destruct</code>는 특정 값을 쪼갰습니다. 예를 들어 어떤 boolean <code class="inline-code-span">b</code>를 <code class="inline-code-span">destruct b</code>하면 <code class="inline-code-span">b</code>가 <code class="inline-code-span">true</code>인 경우와 <code class="inline-code-span">false</code>인 경우로 나눠집니다. 값을 쪼개는게 아니라 식을 쪼갤 수도 있을까요? 아래의 예시를 보겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> compound_false (n </span><span class="color-white">:</span><span class="color-white"> nat) </span><span class="color-white">:</span><span class="color-white"> bool </span><span class="color-white">:=</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">  <span class="color-violet">if</span><span class="color-white"> n </span><span class="color-white">=?</span> <span class="color-gold">3</span> <span class="color-violet">then</span><span class="color-white"> false
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">  <span class="color-violet">else</span> <span class="color-violet">if</span><span class="color-white"> n </span><span class="color-white">=?</span> <span class="color-gold">5</span> <span class="color-violet">then</span><span class="color-white"> false
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">  <span class="color-violet">else</span><span class="color-white"> false</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">
</span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-gold">Theorem</span><span class="color-white"> compound_false_false </span><span class="color-white">:</span><span class="color-white"> forall (n </span><span class="color-white">:</span><span class="color-white"> nat)</span><span class="color-white">,</span><span class="color-white"> compound_false n </span><span class="color-white">=</span><span class="color-white"> false</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(4)">Copy</button></pre><p>위에서 정의한 <code class="inline-code-span">compound_false</code>는 항상 <code class="inline-code-span">false</code>입니다. 사람 눈으로 보기엔 그게 자명하지만 Coq가 봐도 그럴까요? 아쉽게도 그렇지 않습니다. Coq에게는 <code class="inline-code-span">destruct</code>를 이용해서 <code class="inline-code-span">n</code>이 3, 5, 나머지인 경우로 나눠줘야합니다. 아래처럼 말이죠.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Proof</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  intros n</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  unfold compound_false</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  destruct (n </span><span class="color-white">=?</span> <span class="color-gold">3</span><span class="color-white">)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> n =? 3 = true </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">    reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code">  <span class="color-white">-</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> n =? 3 = false </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">    destruct (n </span><span class="color-white">=?</span> <span class="color-gold">5</span><span class="color-white">)</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code">    <span class="color-white">+</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> n =? 5 = true </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">      reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code">    <span class="color-white">+</span><span class="color-white"> (*</span><span class="color-gray">{-</span><span class="color-gray"> n =? 5 = false </span><span class="color-gray">-}</span><span class="color-white">*)
</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code"><span class="color-white">      reflexivity</span><span class="color-white">.</span>
</span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code">  <span class="color-gold">Qed</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(5)">Copy</button></pre><p>위의 식은 <code class="inline-code-span">n</code>에다가 3을 대입하는게 아니고 <code class="inline-code-span">n =? 3</code>에다가 <code class="inline-code-span">true</code>를 대입합니다. 그러면 if문이 통째로 날아가서 <code class="inline-code-span">false</code>와 <code class="inline-code-span">if n =? 5 then ...</code>으로 쪼개집니다. 그렇게되면 저희가 증명하려는 식도 <code class="inline-code-span">false = false</code>의 형태가 되어서 <code class="inline-code-span">reflexivity</code>만으로 증명이 가능해집니다.</p><hr/><div class="align-center"><p><a href="index.html">메인으로 돌아가기</a></p></div><div class="align-left"><p>&lt;&lt; <a href="Chap5-2.html">Chap5-2. Injective and Disjoint</a></p></div><div class="align-right"><p><a href="Chap6-1.html">Chap6-1. Conjunction and Disjunction</a> &gt;&gt;</p></div><hr class="footnote-hr"/><div class="mdxt-footnote-cites"><p><div class="footnote-cite"><a id="footnote-cite-0"></a><a href="#footnote-ref-0"> [0]</a> 제 개인적인 의견입니다.</div></p></div><script>/*<![CDATA[*/
const fenced_code_block_contents = ["Theorem ridiculous : forall (n m p q : nat),\n  (n = m -> p = q) ->\n  m = n ->\n  q = p.\nProof.\n  intros n m p q EQ H.\n  symmetry in H.\n  apply EQ in H.\n  symmetry in H.\n  apply H.\n  Qed.", "Theorem double_injective : forall n m,\n  double n = double m -> n = m.", "Proof.\n  intros n m.\n  generalize dependent n.\n  induction m as [ | m' IHm'].\n  - (*{- m = 0 -}*)\n    intros n eq.\n    induction n as [ | n' IHn'].\n    + (*{- n = 0 -}*)\n      reflexivity.\n    + (*{- n = S n' -}*)\n      discriminate eq.\n  - (*{- m = S m' -}*)\n    intros n eq.\n    induction n as [ | n' IHn'].\n    + (*{- n = 0 -}*)\n      discriminate eq.\n    + (*{- n = S n' -}*)\n      injection eq.\n      intros H.\n      apply IHm' in H.\n      rewrite H.\n      reflexivity.\n  Qed.", "Definition square (n : nat) := n * n.\n\nTheorem square_mult : forall (n m : nat), square (n * m) = square n * square m.", "Definition compound_false (n : nat) : bool :=\n  if n =? 3 then false\n  else if n =? 5 then false\n  else false.\n\nTheorem compound_false_false : forall (n : nat), compound_false n = false.", "Proof.\n  intros n.\n  unfold compound_false.\n  destruct (n =? 3).\n  - (*{- n =? 3 = true -}*)\n    reflexivity.\n  - (*{- n =? 3 = false -}*)\n    destruct (n =? 5).\n    + (*{- n =? 5 = true -}*)\n      reflexivity.\n    + (*{- n =? 5 = false -}*)\n      reflexivity.\n  Qed."];

function copy_code_to_clipboard(index) {
    navigator.clipboard.writeText(fenced_code_block_contents[index]);
}/*]]>*/</script>
        <a id="bottom"></a>
    </article>




    <footer class="markdown">
<p><br/></p><p><br/></p><hr/><div class="align-center"><p>2021 ~ 2023 &copy; Baehyunsol</p></div>
    </footer>


    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
    
    
    <script src="header.js"></script>
    
<script src="collapsible_tables.js"></script></body>

</html>