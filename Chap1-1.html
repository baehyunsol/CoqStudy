<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>Chap1-1</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> 
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/><link href="header.css" rel="stylesheet"/><link href="footer.css" rel="stylesheet"/>
    
</head>

<body>


    <header>
<p><a href="index.html">Home</a></p>
    </header>



    <nav>
<p><a id="settingsopenbutton">&#9728;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p><div id="settingsmenu"> <a id="settingsclosebutton">&#10006;</a> <a id="changethemebutton">Set Light Theme</a> <a id="loosepaddingbutton">&#8592; &#8594;</a> <a id="tightpaddingbutton">&#8594; &#8592;</a> </div></p></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<table><thead id="table-collapse-toggle-0" class="collapsible collapsed" onclick="collapse_table('0')"><tr><th> Table of Contents </th></tr></thead><tbody id="collapsible-table-0" class="invisible"><tr><td><div class="toc"><ol type="1"><li><a href="#coq">Coq</a><ol type="1"><li><a href="#inductive"><code class="inline-code-span">Inductive</code></a></li><li><a href="#definition"><code class="inline-code-span">Definition</code></a></li><li><a href="#notation"><code class="inline-code-span">Notation</code></a></li><li><a href="#if"><code class="inline-code-span">if</code></a></li><li><a href="#check"><code class="inline-code-span">Check</code></a></li><li><a href="#compute"><code class="inline-code-span">Compute</code></a></li><li><a href="#enums">Enums</a></li><li><a href="#modules">Modules</a></li><li><a href="#tuples">Tuples</a></li></ol></li></ol></div></td></tr></tbody></table><h1 id="coq">Coq</h1><p>Coq는 Gallina라는 함수형 언어로 이루어져 있습니다.<sup id="footnote-ref-0"><a href="#footnote-cite-0">[0]</a></sup> Coq에 대해서 본격적으로 공부하기 전에, 함수형 언어로서의 Coq의 특징에 대해서 알아보겠습니다.</p><h2 id="inductive"><code class="inline-code-span">Inductive</code></h2><p><a id="keywordinductive"></a></p><p>Rust의 <code class="inline-code-span">enum</code>에 대응되는 개념으로 coq에는 <code class="inline-code-span">Inductive</code>가 있습니다. Coq의 primitive type들은 대부분 <code class="inline-code-span">Inductive</code>를 통해서 구현돼 있습니다. 즉, 정수형이나 Boolean등도 컴파일러 내부에 구현된 특별한 자료형이 아닌, 다른 모든 자료형과 동일하다는 뜻입니다.</p><p>Boolean이 어떻게 구현돼 있는지 살펴보겠습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Inductive</span><span class="color-white"> bool </span><span class="color-white">:</span><span class="color-white"> </span><span class="color-gold">Type</span><span class="color-white"> </span><span class="color-white">:=</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> true</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> false</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(0)">Copy</button></pre><h2 id="definition"><code class="inline-code-span">Definition</code></h2><p><a id="keyworddefinition"></a></p><p>Rust에 익숙하신 분이라면 위의 코드를 이해하는 것이 어렵지 않을 것입니다. <code class="inline-code-span">bool</code>이란 type을 정의하고, <code class="inline-code-span">bool</code>에는 <code class="inline-code-span">true</code>와 <code class="inline-code-span">false</code>라는 variant가 있음을 정의합니다. 함수를 정의하는 것도 어렵지 않습니다.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> negb (b</span><span class="color-white">:</span><span class="color-white"> bool) </span><span class="color-white">:</span><span class="color-white"> bool </span><span class="color-white">:=</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  match b with</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> true </span><span class="color-white">=&gt;</span><span class="color-white"> false</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> false </span><span class="color-white">=&gt;</span><span class="color-white"> true</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  end</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> andb (b1</span><span class="color-white">:</span><span class="color-white">bool) (b2</span><span class="color-white">:</span><span class="color-white">bool) </span><span class="color-white">:</span><span class="color-white"> bool </span><span class="color-white">:=</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">  match b1 with</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> true </span><span class="color-white">=&gt;</span><span class="color-white"> b2</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> false </span><span class="color-white">=&gt;</span><span class="color-white"> false</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code"><span class="color-white">  end</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> orb (b1</span><span class="color-white">:</span><span class="color-white">bool) (b2</span><span class="color-white">:</span><span class="color-white">bool) </span><span class="color-white">:</span><span class="color-white"> bool </span><span class="color-white">:=</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code"><span class="color-white">  match b1 with</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> true </span><span class="color-white">=&gt;</span><span class="color-white"> true</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> false </span><span class="color-white">=&gt;</span><span class="color-white"> b2</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">17</span><span class="code-fence-code"><span class="color-white">  end</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(1)">Copy</button></pre><div class="box"><p><code class="inline-code-span">Definition</code>은 Rust의 함수 정의보다는 Haskell의 함수 정의에 좀 더 가까운 것 같습니다. 위의 코드에서 <code class="inline-code-span">negb</code>는 <code class="inline-code-span">negb</code>라는 함수를 정의한 것이 아니고 단지 <code class="inline-code-span">bool</code> 값을 정의한 것에 불과합니다. 다만 그 값이 <code class="inline-code-span">b</code>라는 다른 인수에 의해 결정될 뿐입니다. 상수 정의도 이것과 동일한 syntax로 할 수 있습니다.</p><p><em>이 박스 안의 내용은 제 추측입니다. 아직 공부 중이라, 틀린 내용이 있을 수 있습니다.</em></p></div><p><code class="inline-code-span">match</code>문은 Rust의 <code class="inline-code-span">match</code>문과 대응됩니다.</p><p>함수를 호출하는 방식은 Lisp 혹은 Haskell과 비슷합니다. <code class="inline-code-span">orb false false</code>는 <code class="inline-code-span">false</code>와 <code class="inline-code-span">false</code>란 값을 인수로 넘겨서 <code class="inline-code-span">orb</code> 함수를 호출합니다. <code class="inline-code-span">orb false (orb false false)</code>와 같은 형식으로 괄호를 이용해 중의성을 해소할 수 있습니다.</p><h2 id="notation"><code class="inline-code-span">Notation</code></h2><p><a id="keywordnotation"></a></p><p>바로 <a href="#keyworddefinition">위</a>에서 정의했던 것 같은 Lisp 스타일의 함수 호출도 좋지만 C나 수학 스타일의 중위 연산자가 그리울 때가 있습니다. Coq의 <code class="inline-code-span">Notation</code> 키워드는 중위 연산자를 정의할 수 있게 해줍니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Notation</span><span class="color-white"> </span><span class="color-white">&quot;</span><span class="color-green">x &amp;&amp; y</span><span class="color-white">&quot;</span><span class="color-white"> </span><span class="color-white">:=</span><span class="color-white"> (andb x y)</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gold">Notation</span><span class="color-white"> </span><span class="color-white">&quot;</span><span class="color-green">x || y</span><span class="color-white">&quot;</span><span class="color-white"> </span><span class="color-white">:=</span><span class="color-white"> (orb x y)</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(2)">Copy</button></pre><p>이제 우리는 <code class="inline-code-span">andb x y</code>라는 Lisp스러운 표현대신 <code class="inline-code-span">x &amp;&amp; y</code>라는 일반적인 표현을 사용할 수 있습니다.</p><h2 id="if"><code class="inline-code-span">if</code></h2><p><a id="keywordif"></a></p><p>함수형 패러다임을 지원하는 최신 언어들이 대부분 그러하듯, Coq의 <code class="inline-code-span">if</code> 또한 expression으로 취급됩니다. 위에서 방금 정의했던 함수들은 아래와 같이 다시 정의할 수 있습니다.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> negb (b</span><span class="color-white">:</span><span class="color-white">bool) </span><span class="color-white">:</span><span class="color-white"> bool </span><span class="color-white">:=</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-violet">if</span><span class="color-white"> b </span><span class="color-violet">then</span><span class="color-white"> false</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-violet">else</span><span class="color-white"> true</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> andb (b1</span><span class="color-white">:</span><span class="color-white">bool) (b2</span><span class="color-white">:</span><span class="color-white">bool) </span><span class="color-white">:</span><span class="color-white"> bool </span><span class="color-white">:=</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-violet">if</span><span class="color-white"> b1 </span><span class="color-violet">then</span><span class="color-white"> b2</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-violet">else</span><span class="color-white"> false</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> orb (b1</span><span class="color-white">:</span><span class="color-white">bool) (b2</span><span class="color-white">:</span><span class="color-white">bool) </span><span class="color-white">:</span><span class="color-white"> bool </span><span class="color-white">:=</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-violet">if</span><span class="color-white"> b1 </span><span class="color-violet">then</span><span class="color-white"> true</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-violet">else</span><span class="color-white"> b2</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(3)">Copy</button></pre><p><code class="inline-code-span">if</code> 문 뒤에 조건이 오고, 그 뒤에 <code class="inline-code-span">then</code>과 <code class="inline-code-span">else</code>가 오는 구조입니다. 위에서도 말했듯, Coq에서 <code class="inline-code-span">bool</code>은 special primitive가 아니기에 <code class="inline-code-span">if</code> 문의 조건에 <code class="inline-code-span">bool</code>만 쓸 수 있게 하는 것은 이치에 맞지 않습니다. 따라서, <code class="inline-code-span">if</code>문의 조건에는 모든 type을 다 사용할 수 있습니다(단, 그 type의 variant가 2개이어야 합니다). 그럼 뭐가 참이고 뭐가 거짓인지 어떻게 구분할지 혼란스러울텐데, <code class="inline-code-span">Inductive</code> 문의 정의 안에서 먼저 정의된 variant를 참으로 간주합니다. <a href="#keywordinductive">위</a>에서 <code class="inline-code-span">true</code>가 <code class="inline-code-span">false</code>보다 먼저 정의됐으니, 이 코드에서는 <code class="inline-code-span">true</code>가 참으로 간주됩니다.</p><h2 id="check"><code class="inline-code-span">Check</code></h2><p><a id="keywordcheck"></a></p><p><code class="inline-code-span">Check</code>는 값을 받아서 그 값의 type을 반환하는 명령어<sup id="footnote-ref-1"><a href="#footnote-cite-1">[1]</a></sup>입니다.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-white">(*</span><span class="color-gray">{-</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gray">Coq의 주석은</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gray">(* .. 주석 .. *)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gray">와 같은 형태로 씁니다. 하지만 Coq의 문법을 지원하는 syntax highlighter를 찾지 못하여 부득이하게</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-gray">Haskell 스타일로 주석을 썼습니다.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> true</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> true : bool </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> (andb true true)</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> true : bool </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code"><span class="color-white">(*</span><span class="color-gray">{-</span><span class="color-gray"> Coq에서는 함수도 first class object입니다. </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> andb</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> andb : bool -&gt; bool </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code"><span class="color-white">(*</span><span class="color-gray">{-</span><span class="color-gray"> `Check`는 일반적인 함수가 아니기에 type이 없습니다. </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> </span><span class="color-gold">Check</span><span class="color-white">.</span><span class="color-white">  (*</span><span class="color-gray">{-</span><span class="color-gray"> error </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(4)">Copy</button></pre><p>혹은 <code class="inline-code-span">Check value : Type.</code>의 형태로 theorem prover에게 type이 맞는지 질의할 수도 있습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> true </span><span class="color-white">:</span><span class="color-white"> bool</span><span class="color-white">.</span></span></span>
</code></pre><p>위와 같이 쓸 경우, <code class="inline-code-span">true</code>가 <code class="inline-code-span">bool</code> type이 맞으면 넘어가고 그렇지 않을 경우 틀렸다고 알려줍니다.</p><p>문득 Coq의 type이 어떤 식으로 작동하는지 궁금해져서 몇가지 질의를 더 해보았습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> true</span><span class="color-white">.</span><span class="color-white">  (*</span><span class="color-gray">{-</span><span class="color-gray"> true : bool </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> bool</span><span class="color-white">.</span><span class="color-white">  (*</span><span class="color-gray">{-</span><span class="color-gray"> bool : Set  </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> </span><span class="color-gold">Set</span><span class="color-white">.</span><span class="color-white">   (*</span><span class="color-gray">{-</span><span class="color-gray"> Set : Type  </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> </span><span class="color-gold">Type</span><span class="color-white">.</span><span class="color-white">  (*</span><span class="color-gray">{-</span><span class="color-gray"> Type : Type </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(6)">Copy</button></pre><p>사용자가 <code class="inline-code-span">Inductive</code> 키워드를 이용해서 정의한 type들은 <code class="inline-code-span">Set</code>이란 type을 가지고 <code class="inline-code-span">Set</code>은 <code class="inline-code-span">Type</code>이란 type을 가집니다.</p><h2 id="compute"><code class="inline-code-span">Compute</code></h2><p><a id="keywordcompute"></a></p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Compute</span><span class="color-white"> negb true</span><span class="color-white">.</span><span class="color-white">  (*</span><span class="color-gray">{-</span><span class="color-gray"> = false : bool </span><span class="color-gray">-}</span><span class="color-white">*)</span></span></span>
</code></pre><p><code class="inline-code-span">Compute</code>는 주어진 식을 계산합니다. <code class="inline-code-span">Check</code>와 마찬가지로 함수가 아니고 명령어입니다.</p><h2 id="enums">Enums</h2><p>Rust 혹은 Haskell을 할 줄 아시는 분은 enum을 만들면서 variant 안에 다양한 값을 넣어본 기억이 있으실 겁니다. Coq에서도 비슷한 방식의 type 정의를 지원합니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Inductive</span><span class="color-white"> rgb </span><span class="color-white">:</span><span class="color-white"> </span><span class="color-gold">Type</span><span class="color-white"> </span><span class="color-white">:=</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> red</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> green</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> blue</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-gold">Inductive</span><span class="color-white"> color </span><span class="color-white">:</span><span class="color-white"> </span><span class="color-gold">Type</span><span class="color-white"> </span><span class="color-white">:=</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> black</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> white</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> primary (p </span><span class="color-white">:</span><span class="color-white"> rgb)</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(8)">Copy</button></pre><p>Rust에서 enum을 정의하는 방법과 동일합니다. <code class="inline-code-span">color</code>라는 enum은 <code class="inline-code-span">primary</code>라는 variant를 가지고, <code class="inline-code-span">primary</code>는 <code class="inline-code-span">rgb</code>의 instance 하나를 멤버로 가집니다. <code class="inline-code-span">color</code>를 패턴매칭으로 뜯어내는 방식은 Haskell과 비슷합니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> is_red_or_black(c</span><span class="color-white">:</span><span class="color-white"> color) </span><span class="color-white">:</span><span class="color-white"> bool </span><span class="color-white">:=</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  match c with</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> black </span><span class="color-white">=&gt;</span><span class="color-white"> true</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> white </span><span class="color-white">=&gt;</span><span class="color-white"> false</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> primary red </span><span class="color-white">=&gt;</span><span class="color-white"> true</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> primary _ </span><span class="color-white">=&gt;</span><span class="color-white"> false</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">  end</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(9)">Copy</button></pre><p>위의 <code class="inline-code-span">primary red</code>처럼, variant와 그 안의 값을 패턴매칭합니다. <code class="inline-code-span">_</code>는 와일드카드 문자로 사용됩니다.</p><h2 id="modules">Modules</h2><p><a id="keywordmodule"></a></p><p>Module은 C++의 namespace와 비슷한 개념입니다. 아니, 그냥 똑같습니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Module</span><span class="color-white"> </span><span class="color-gold">Playground</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-gold">Definition</span><span class="color-white"> b </span><span class="color-white">:</span><span class="color-white"> rgb </span><span class="color-white">:=</span><span class="color-white"> blue</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-gold">End</span><span class="color-white"> </span><span class="color-gold">Playground</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> b </span><span class="color-white">:</span><span class="color-white"> bool </span><span class="color-white">:=</span><span class="color-white"> true</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> </span><span class="color-gold">Playground</span><span class="color-white">.</span><span class="color-white">b </span><span class="color-white">:</span><span class="color-white"> rgb</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> b </span><span class="color-white">:</span><span class="color-white"> bool</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(10)">Copy</button></pre><p>위의 코드에서 <code class="inline-code-span">Playground</code>라는 모듈을 정의하고 그 안에서 <code class="inline-code-span">b</code>라는 값을 정의했습니다. <code class="inline-code-span">b</code>는 모듈 안에서 정의됐으므로, global context에서 그냥 <code class="inline-code-span">b</code>와 <code class="inline-code-span">Playground.b</code>가 구분됩니다.</p><h2 id="tuples">Tuples</h2><p><a id="concepttuple"></a></p><p>Rust 혹은 Haskell을 다뤄본 적이 있다면 tuple이라는 개념이 아주 익숙하실 겁니다.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Inductive</span><span class="color-white"> bit </span><span class="color-white">:</span><span class="color-white"> </span><span class="color-gold">Type</span><span class="color-white"> </span><span class="color-white">:=</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> </span><span class="color-gold">B0</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> </span><span class="color-gold">B1</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-gold">Inductive</span><span class="color-white"> nybble </span><span class="color-white">:</span><span class="color-white"> </span><span class="color-gold">Type</span><span class="color-white"> </span><span class="color-white">:=</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> bits (b0 b1 b2 b3 </span><span class="color-white">:</span><span class="color-white"> bit)</span><span class="color-white">.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-gold">Check</span><span class="color-white"> (bits </span><span class="color-gold">B1</span><span class="color-white"> </span><span class="color-gold">B0</span><span class="color-white"> </span><span class="color-gold">B1</span><span class="color-white"> </span><span class="color-gold">B0</span><span class="color-white">)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">:</span><span class="color-white"> nybble</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(11)">Copy</button></pre><p>위와 같이 <code class="inline-code-span">bit</code> type 4개로 이뤄진 <code class="inline-code-span">bits</code>라는 type을 정의했습니다. 다른 언어들과 달리 tuple을 이루는 원소들은 전부 동일한 type을 가져야하는 것 같습니다.</p><div class="box"><p>TODO:</p><p>진짜 type이 다 동일해야하나? 그럴 거면 뭐하러 tuple을 쓰지?</p><p><code class="inline-code-span">(n m : nat)</code>와 <code class="inline-code-span">(n : nat) (m : nat)</code>가 동일한 의미라고 하는 걸로 봐서는 tuple의 표현방식도 다른 게 있을 거 같은데...</p></div><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gold">Definition</span><span class="color-white"> all_zero (nb </span><span class="color-white">:</span><span class="color-white"> nybble) </span><span class="color-white">:</span><span class="color-white"> bool </span><span class="color-white">:=</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">  match nb with</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> (bits </span><span class="color-gold">B0</span><span class="color-white"> </span><span class="color-gold">B0</span><span class="color-white"> </span><span class="color-gold">B0</span><span class="color-white"> </span><span class="color-gold">B0</span><span class="color-white">) </span><span class="color-white">=&gt;</span><span class="color-white"> true</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">  </span><span class="color-white">|</span><span class="color-white"> (bits _ _ _ _) </span><span class="color-white">=&gt;</span><span class="color-white"> false</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">  end</span><span class="color-white">.</span></span></span>
</code><button class="copy-fenced-code" onclick="copy_code_to_clipboard(12)">Copy</button></pre><p>Tuple을 패턴매칭하는 것도 위와 같이 어렵지 않습니다.</p><hr/><div class="align-center"><p><a href="index.html">메인으로 돌아가기</a></p></div><div class="align-left"><p>이전 글이 없습니다.</p></div><div class="align-right"><p><a href="Chap1-2.html">Chap1-2. Natural Numbers</a> &gt;&gt;</p></div><hr class="footnote-hr"/><div class="mdxt-footnote-cites"><p><div class="footnote-cite"><a id="footnote-cite-0"></a>0. <a href="#footnote-ref-0"> [0]</a> 막상 책에서는 <em>Coq 언어</em>라고 지칭을 할 때가 많아서 어디까지가 무슨 언어인지 사실 저도 잘 모르겠어요. 이 문서에는 Gallina는 더 이상 언급하지 않고, 전부 Coq라는 표현만 썼습니다.</div><div class="footnote-cite"><a id="footnote-cite-1"></a>1. <a href="#footnote-ref-1"> [1]</a> <code class="inline-code-span">Check</code>는 일반적인 함수가 아닙니다. 아래에서 자세히 설명하겠습니다. <br/><em>function</em>이라는 용어는 전부 <em>함수</em>로 번역했고, <em>command</em>는 전부 <em>명령어</em>로 번역했습니다. 문서에서 두 용어를 완전히 구분해서 사용할테니 읽는데 혼동이 없으시길 바라겠습니다.</div></p></div><script>/*<![CDATA[*/
const fenced_code_block_contents = ["Inductive bool : Type :=\n  | true\n  | false.", "Definition negb (b: bool) : bool :=\n  match b with\n  | true => false\n  | false => true\n  end.\n\nDefinition andb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => b2\n  | false => false\n  end.\n\nDefinition orb (b1:bool) (b2:bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end.", "Notation \"x && y\" := (andb x y).\nNotation \"x || y\" := (orb x y).", "Definition negb (b:bool) : bool :=\n  if b then false\n  else true.\nDefinition andb (b1:bool) (b2:bool) : bool :=\n  if b1 then b2\n  else false.\nDefinition orb (b1:bool) (b2:bool) : bool :=\n  if b1 then true\n  else b2.", "(*{-\nCoq의 주석은\n(* .. 주석 .. *)\n와 같은 형태로 씁니다. 하지만 Coq의 문법을 지원하는 syntax highlighter를 찾지 못하여 부득이하게\nHaskell 스타일로 주석을 썼습니다.\n-}*)\n\nCheck true.   (*{- true : bool -}*)\nCheck (andb true true).   (*{- true : bool -}*)\n\n(*{- Coq에서는 함수도 first class object입니다. -}*)\nCheck andb.   (*{- andb : bool -> bool -}*)\n\n(*{- `Check`는 일반적인 함수가 아니기에 type이 없습니다. -}*)\nCheck Check.  (*{- error -}*)", "", "Check true.  (*{- true : bool -}*)\nCheck bool.  (*{- bool : Set  -}*)\nCheck Set.   (*{- Set : Type  -}*)\nCheck Type.  (*{- Type : Type -}*)", "", "Inductive rgb : Type :=\n  | red\n  | green\n  | blue.\nInductive color : Type :=\n  | black\n  | white\n  | primary (p : rgb).", "Definition is_red_or_black(c: color) : bool :=\n  match c with\n  | black => true\n  | white => false\n  | primary red => true\n  | primary _ => false\n  end.", "Module Playground.\n  Definition b : rgb := blue.\nEnd Playground.\n\nDefinition b : bool := true.\n\nCheck Playground.b : rgb.\nCheck b : bool.", "Inductive bit : Type :=\n  | B0\n  | B1.\nInductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit).\nCheck (bits B1 B0 B1 B0)\n  : nybble.", "Definition all_zero (nb : nybble) : bool :=\n  match nb with\n  | (bits B0 B0 B0 B0) => true\n  | (bits _ _ _ _) => false\n  end."];

function copy_code_to_clipboard(index) {
    navigator.clipboard.writeText(fenced_code_block_contents[index]);
}/*]]>*/</script>
        <a id="bottom"></a>
    </article>




    <footer class="markdown">
<p><br/></p><p><br/></p><hr/><div class="align-center"><p>2021 ~ 2022 (c) Baehyunsol</p><p>Powered by <a href="https://github.com/baehyunsol/MDxt">MDxt</a></p></div>
    </footer>


    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
<script src="collapsible_tables.js"></script></body>

</html>